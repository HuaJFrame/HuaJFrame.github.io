<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据库逆向工程</title>
    <link href="/2023/03/06/%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <url>/2023/03/06/%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="MyBatis-Generator"><a href="#MyBatis-Generator" class="headerlink" title="MyBatis Generator"></a>MyBatis Generator</h2><h3 id="Maven插件依赖"><a href="#Maven插件依赖" class="headerlink" title="Maven插件依赖"></a>Maven插件依赖</h3><blockquote><p>实际需求修改请看 <a href="http://mybatis.org/generator/running/runningWithMaven.html">http://mybatis.org/generator/running/runningWithMaven.html</a></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 构建过程中用到的插件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 插件的依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 数据库连接池 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.mchange<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>c3p0<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- MySQL驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="逆向工程的配置文件"><a href="#逆向工程的配置文件" class="headerlink" title="逆向工程的配置文件"></a>逆向工程的配置文件</h3><p>文件名必须是：<code>generatorConfig.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 指定本地数据库驱动位置 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;classPathEntry location=&quot;/Program Files/IBM/SQLLIB/java/db2java.zip&quot; /&gt; --&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    targetRuntime: 执行生成的逆向工程的版本</span><br><span class="hljs-comment">    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span><br><span class="hljs-comment">    MyBatis3: 生成带条件的CRUD（奢华尊享版）</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;DB2Tables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3Simple&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 是否生成注释 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressDate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据库的连接信息 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;123456&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- javaBean的生成策略--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.pojo&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span></span><br><span class="hljs-tag">                         <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\resources&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Mapper接口的生成策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span></span><br><span class="hljs-tag">                             <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.atguigu.mybatis.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;.\src\main\java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 逆向分析的表 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span><br>        <span class="hljs-comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- http://mybatis.org/generator/configreference/table.html --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_emp&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Emp&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_dept&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Dept&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行命令: <code>mvn mybatis-generator:generate</code></p><h1 id="Mybaits-Plus"><a href="#Mybaits-Plus" class="headerlink" title="Mybaits-Plus"></a>Mybaits-Plus</h1><p>可以用idea MybaitsX插件</p><h2 id="代码生成器（新，3-5-1版本及以上）"><a href="#代码生成器（新，3-5-1版本及以上）" class="headerlink" title="代码生成器（新，3.5.1版本及以上）"></a>代码生成器（新，3.5.1版本及以上）</h2><blockquote><p>参考连接 <a href="https://juejin.cn/post/7033399493684903949">https://juejin.cn/post/7033399493684903949</a></p></blockquote><h3 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.velocity<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>velocity-engine-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- lombok，按需导入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>MyBatis Plus Generator</code>支持的模板引擎有<code>Velocity</code>、<code>Beetl</code>、<code>FreeMarker</code>，按需导入</p><h3 id="代码实现一"><a href="#代码实现一" class="headerlink" title="代码实现一"></a>代码实现一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//1、配置数据源</span><br>    FastAutoGenerator.create(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mp&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>)<br>        <span class="hljs-comment">//2、全局配置</span><br>        .globalConfig(builder -&gt; &#123;<br>            builder.author(<span class="hljs-string">&quot;Hua JFrame&quot;</span>) <span class="hljs-comment">// 设置作者名</span><br>                .outputDir(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;/src/main/java&quot;</span>)   <span class="hljs-comment">//设置输出路径：项目的 java 目录下</span><br>                .commentDate(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>)   <span class="hljs-comment">//注释日期</span><br>                .dateType(DateType.ONLY_DATE)   <span class="hljs-comment">//定义生成的实体类中日期的类型 TIME_PACK=LocalDateTime;ONLY_DATE=Date;</span><br>                .fileOverride()   <span class="hljs-comment">//覆盖之前的文件</span><br>                .enableSwagger()   <span class="hljs-comment">//开启 swagger 模式</span><br>                .disableOpenDir();   <span class="hljs-comment">//禁止打开输出目录，默认打开</span><br>        &#125;)<br>        <span class="hljs-comment">//3、包配置</span><br>        .packageConfig(builder -&gt; &#123;<br>            builder.parent(<span class="hljs-string">&quot;com&quot;</span>) <span class="hljs-comment">// 设置父包名</span><br>                .moduleName(<span class="hljs-string">&quot;mp&quot;</span>)   <span class="hljs-comment">//设置模块包名</span><br>                .entity(<span class="hljs-string">&quot;entity&quot;</span>)   <span class="hljs-comment">//pojo 实体类包名</span><br>                .service(<span class="hljs-string">&quot;service&quot;</span>) <span class="hljs-comment">//Service 包名</span><br>                .serviceImpl(<span class="hljs-string">&quot;serviceImpl&quot;</span>) <span class="hljs-comment">// ***ServiceImpl 包名</span><br>                .mapper(<span class="hljs-string">&quot;mapper&quot;</span>)   <span class="hljs-comment">//Mapper 包名</span><br>                .xml(<span class="hljs-string">&quot;mapper&quot;</span>)  <span class="hljs-comment">//Mapper XML 包名</span><br>                .controller(<span class="hljs-string">&quot;controller&quot;</span>) <span class="hljs-comment">//Controller 包名</span><br>                .other(<span class="hljs-string">&quot;utils&quot;</span>) <span class="hljs-comment">//自定义文件包名</span><br>                .pathInfo(Collections.singletonMap(OutputFile.mapperXml, System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>)+<span class="hljs-string">&quot;/src/main/resources/mapper&quot;</span>))    <span class="hljs-comment">//配置 mapper.xml 路径信息：项目的 resources 目录下</span><br>        &#125;)<br>        <span class="hljs-comment">//4、策略配置</span><br>        .strategyConfig(builder -&gt; &#123;<br>            builder.addInclude(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;student&quot;</span>) <span class="hljs-comment">// 设置需要生成的数据表名</span><br>                .addTablePrefix(<span class="hljs-string">&quot;t_&quot;</span>, <span class="hljs-string">&quot;c_&quot;</span>) <span class="hljs-comment">// 设置过滤表前缀</span><br><br>                <span class="hljs-comment">//4.1、Mapper策略配置</span><br>                .mapperBuilder()<br>                .superClass(BaseMapper.class)   <span class="hljs-comment">//设置父类</span><br>                .formatMapperFileName(<span class="hljs-string">&quot;%sMapper&quot;</span>)   <span class="hljs-comment">//格式化 mapper 文件名称</span><br>                .enableMapperAnnotation()       <span class="hljs-comment">//开启 @Mapper 注解</span><br>                .formatXmlFileName(<span class="hljs-string">&quot;%sXml&quot;</span>); <span class="hljs-comment">//格式化 Xml 文件名称</span><br><br>            <span class="hljs-comment">//4.2、service 策略配置</span><br>            .serviceBuilder()<br>                .formatServiceFileName(<span class="hljs-string">&quot;%sService&quot;</span>) <span class="hljs-comment">//格式化 service 接口文件名称，%s进行匹配表名，如 UserService</span><br>                .formatServiceImplFileName(<span class="hljs-string">&quot;%sServiceImpl&quot;</span>) <span class="hljs-comment">//格式化 service 实现类文件名称，%s进行匹配表名，如 UserServiceImpl</span><br><br>                <span class="hljs-comment">//4.3、实体类策略配置</span><br>                .entityBuilder()<br>                .enableLombok() <span class="hljs-comment">//开启 Lombok</span><br>                .disableSerialVersionUID()  <span class="hljs-comment">//不实现 Serializable 接口，不生产 SerialVersionUID</span><br>                .logicDeleteColumnName(<span class="hljs-string">&quot;deleted&quot;</span>)   <span class="hljs-comment">//逻辑删除字段名</span><br>                .naming(NamingStrategy.underline_to_camel)  <span class="hljs-comment">//数据库表映射到实体的命名策略：下划线转驼峰命</span><br>                .columnNaming(NamingStrategy.underline_to_camel)    <span class="hljs-comment">//数据库表字段映射到实体的命名策略：下划线转驼峰命</span><br>                .addTableFills(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Column</span>(<span class="hljs-string">&quot;create_time&quot;</span>, FieldFill.INSERT),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Column</span>(<span class="hljs-string">&quot;modify_time&quot;</span>, FieldFill.INSERT_UPDATE)<br>            )   <span class="hljs-comment">//添加表字段填充，&quot;create_time&quot;字段自动填充为插入时间，&quot;modify_time&quot;字段自动填充为插入修改时间</span><br>                .enableTableFieldAnnotation()       <span class="hljs-comment">// 开启生成实体时生成字段注解</span><br><br>                <span class="hljs-comment">//4.4、Controller策略配置</span><br>                .controllerBuilder()<br>                .formatFileName(<span class="hljs-string">&quot;%sController&quot;</span>) <span class="hljs-comment">//格式化 Controller 类文件名称，%s进行匹配表名，如 UserController</span><br>                .enableRestStyle()  <span class="hljs-comment">//开启生成 @RestController 控制器</span><br>        &#125;)<br>        <span class="hljs-comment">//5、模板</span><br>        .templateEngine(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityTemplateEngine</span>())<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">                .templateEngine(new FreemarkerTemplateEngine())</span><br><span class="hljs-comment">                .templateEngine(new BeetlTemplateEngine())</span><br><span class="hljs-comment">                */</span><br>        <span class="hljs-comment">//6、执行</span><br>        .execute();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代码实现二（交互式生成）"><a href="#代码实现二（交互式生成）" class="headerlink" title="代码实现二（交互式生成）"></a>代码实现二（交互式生成）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CodeGenerator</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;=====================数据库配置=======================&quot;</span>);<br>        <span class="hljs-comment">// System.out.println(&quot;请输入 URL&quot;);</span><br>        <span class="hljs-comment">// String url = scan.next();</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/seckill?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;请输入 username&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> scan.next();<br>        System.out.println(<span class="hljs-string">&quot;请输入 password&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> scan.next();<br><br>        FastAutoGenerator.create(url, username, password)<br>                <span class="hljs-comment">// 全局配置</span><br>                .globalConfig((scanner, builder) -&gt; builder.author(scanner.apply(<span class="hljs-string">&quot;=====================全局配置=======================\n请输入作者名称？&quot;</span>))<br>                        .outputDir(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>) + <span class="hljs-string">&quot;/src/main/java&quot;</span>)<br>                        .commentDate(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>)<br>                        .dateType(DateType.TIME_PACK)<br>                        .fileOverride()<br>                        .disableOpenDir()<br>                )<br>                <span class="hljs-comment">// 包配置</span><br>                .packageConfig((scanner, builder) -&gt; builder.parent(scanner.apply(<span class="hljs-string">&quot;=====================包配置=======================\n请输入包名？&quot;</span>))<br>                        .moduleName(scanner.apply(<span class="hljs-string">&quot;请输入父包模块名？&quot;</span>))<br>                        .entity(<span class="hljs-string">&quot;entity&quot;</span>)<br>                        .service(<span class="hljs-string">&quot;service&quot;</span>)<br>                        .serviceImpl(<span class="hljs-string">&quot;service.impl&quot;</span>)<br>                        .mapper(<span class="hljs-string">&quot;dao&quot;</span>)<br>                        .xml(<span class="hljs-string">&quot;mapper&quot;</span>)<br>                        .pathInfo(Collections.singletonMap(OutputFile.xml, System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>)+<span class="hljs-string">&quot;/src/main/resources/mapper&quot;</span>))<br>                )<br>                <span class="hljs-comment">// 策略配置</span><br>                .strategyConfig((scanner, builder) -&gt; &#123;<br>                    builder.addInclude(getTables(scanner.apply(<span class="hljs-string">&quot;=====================策略配置=======================\n请输入表名，多个英文逗号分隔？所有输入 all&quot;</span>)))<br>                            .addTablePrefix(<span class="hljs-string">&quot;t_&quot;</span>)  <span class="hljs-comment">//设置表前缀</span><br>                            .serviceBuilder()<br>                            .formatServiceFileName(<span class="hljs-string">&quot;I%sService&quot;</span>)<br>                            .formatServiceImplFileName(<span class="hljs-string">&quot;%sServiceImpl&quot;</span>)<br>                            .entityBuilder()        <span class="hljs-comment">//实体类策略配置</span><br>                            .enableLombok()         <span class="hljs-comment">//开启 Lombok</span><br>                            .disableSerialVersionUID()<br>                            <span class="hljs-comment">// .logicDeleteColumnName(&quot;deleted&quot;)        //逻辑删除字段</span><br>                            .naming(NamingStrategy.underline_to_camel)<br>                            .columnNaming(NamingStrategy.underline_to_camel)<br>                            .addTableFills(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Column</span>(<span class="hljs-string">&quot;create_time&quot;</span>, FieldFill.INSERT), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Column</span>(<span class="hljs-string">&quot;modify_time&quot;</span>, FieldFill.INSERT_UPDATE))<br>                            <span class="hljs-comment">// .enableTableFieldAnnotation()       // 开启生成实体时生成字段注解</span><br>                            .controllerBuilder()<br>                            .formatFileName(<span class="hljs-string">&quot;%sController&quot;</span>)<br>                            <span class="hljs-comment">// .enableRestStyle()</span><br>                            .mapperBuilder()<br>                            .superClass(BaseMapper.class)<br>                            .formatMapperFileName(<span class="hljs-string">&quot;%sMapper&quot;</span>)<br>                            <span class="hljs-comment">// .enableMapperAnnotation()       //@mapper</span><br>                            .formatXmlFileName(<span class="hljs-string">&quot;%sMapper&quot;</span>)<br>                            .enableBaseColumnList()<br>                            .enableBaseResultMap();<br>                &#125;)<br>                .templateEngine(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FreemarkerTemplateEngine</span>())<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                模板引擎配置，默认 Velocity 可选模板引擎 Beetl 或 Freemarker</span><br><span class="hljs-comment">                .templateEngine(new BeetlTemplateEngine())</span><br><span class="hljs-comment">                .templateEngine(new FreemarkerTemplateEngine())</span><br><span class="hljs-comment">                             */</span><br>                .execute();<br>    &#125;<br><br>    <span class="hljs-comment">// 处理 all 情况</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getTables</span><span class="hljs-params">(String tables)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;all&quot;</span>.equals(tables) ? Collections.emptyList() : Arrays.asList(tables.split(<span class="hljs-string">&quot;,&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>数据库代码自动生成器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用正则表达式</title>
    <link href="/2023/03/05/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/03/05/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转自： <a href="https://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html">https://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html</a></p></blockquote><h3 id="一、校验数字的表达式"><a href="#一、校验数字的表达式" class="headerlink" title="一、校验数字的表达式"></a>一、校验数字的表达式</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">数字：^[0-9]*$<br><br>n位的数字：^\d&#123;n&#125;$<br><br>至少n位的数字：^\d&#123;n,&#125;$<br><br>m-n位的数字：^\d&#123;m,n&#125;$<br><br>零和非零开头的数字：^(0|[1-9][0-9]*)$<br><br>非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$<br><br>带1-2位小数的正数或负数：^(\-)?\d+(\.\d&#123;1,2&#125;)?$<br><br>正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$<br><br>有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$<br><br>有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$<br><br>非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$<br><br>非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$<br><br>非负整数：^\d+$ 或 ^[1-9]\d*|0$<br><br>非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$<br><br>非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$<br><br>非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$<br><br>正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$<br><br>负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$<br><br>浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$<br></code></pre></td></tr></table></figure><h3 id="二、校验字符的表达式"><a href="#二、校验字符的表达式" class="headerlink" title="二、校验字符的表达式"></a>二、校验字符的表达式</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$<br><br>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$<br><br>长度为3-20的所有字符：^.&#123;3,20&#125;$<br><br>由26个英文字母组成的字符串：^[A-Za-z]+$<br><br>由26个大写英文字母组成的字符串：^[A-Z]+$<br><br>由26个小写英文字母组成的字符串：^[a-z]+$<br><br>由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$<br><br>由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$<br><br>中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$<br><br>中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$<br><br>可以输入含有^%&amp;&#x27;,;=?$\&quot;等字符：[^%&amp;&#x27;,;=?$\x22]+<br><br>禁止输入含有~的字符：[^~\x22]+<br></code></pre></td></tr></table></figure><h3 id="三、特殊需求表达式"><a href="#三、特殊需求表达式" class="headerlink" title="三、特殊需求表达式"></a>三、特殊需求表达式</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs TEXT">Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$<br><br>域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?<br><br>InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$<br><br>手机号码：^(13[0-9]|14[0-9]|15[0-9]|16[0-9]|17[0-9]|18[0-9]|19[0-9])\d&#123;8&#125;$ (由于工信部放号段不定时，所以建议使用泛解析 ^([1][3,4,5,6,7,8,9])\d&#123;9&#125;$)<br><br>电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ <br><br>国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125; <br><br>18位身份证号码(数字、字母x结尾)：^((\d&#123;18&#125;)|([0-9x]&#123;18&#125;)|([0-9X]&#123;18&#125;))$<br><br>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$<br><br>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$<br><br>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$<br><br>日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;<br><br>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$<br><br>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ <br><br>钱的输入格式：<br>    1. 有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$ <br><br>    2. 这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$<br><br>    3. 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ <br><br>    4. 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$<br><br>    5. 必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$<br><br>    6. 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ <br><br>    7. 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$<br><br>    8. 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$<br><br>        备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里<br><br>xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$<br><br>中文字符的正则表达式：[\u4e00-\u9fa5]<br><br>双字节字符：[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))<br><br>空白行的正则表达式：\n\s*\r    (可以用来删除空白行)<br><br>HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)<br><br>首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)<br><br>腾讯QQ号：[1-9][0-9]&#123;4,&#125;    (腾讯QQ号从10000开始)<br><br>中国邮政编码：[1-9]\d&#123;5&#125;(?!\d)    (中国邮政编码为6位数字)<br><br>IP地址：\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)<br><br>IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))    (由@飞龙三少 提供,感谢共享)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用工具类</title>
    <link href="/2023/03/05/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <url>/2023/03/05/%E5%B7%A5%E5%85%B7/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>均来自互联网，自己有些微改动，持续更新中</p></blockquote><h3 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h3><p>Maven 依赖–spring boot</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--md5加密依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-codec<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-codec<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MD5Util</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 盐</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SALT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1a2b3c4d&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">md5</span><span class="hljs-params">(String src)</span>&#123;<br>        <span class="hljs-keyword">return</span> DigestUtils.md5Hex(src);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第一次加密</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inputPass 前端输入的密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 加密后的密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  String <span class="hljs-title function_">inputPassToFormPass</span><span class="hljs-params">(String inputPass)</span>&#123;<br>        <span class="hljs-comment">//md5加密密码前，先对密码进行处理，按以下salt的规则处理密码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> + SALT.charAt(<span class="hljs-number">0</span>) + SALT.charAt(<span class="hljs-number">3</span>) +<br>                inputPass + SALT.charAt(<span class="hljs-number">2</span>) + SALT.charAt(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">return</span> md5(str);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 第二次加密</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> formPass 第一次加密后的结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> salt 盐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 加密后的存入数据库的密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">formPassToDBPass</span><span class="hljs-params">(String formPass, String salt)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span> + salt.charAt(<span class="hljs-number">1</span>) + salt.charAt(<span class="hljs-number">5</span>) + formPass + salt.charAt(<span class="hljs-number">3</span>) + salt.charAt(<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">return</span> md5(str);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实际调用的方法，直接包含两次加密</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> inputPass 前端输入密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> salt 盐</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 加密后的存入数据库的密码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">inputPassToDBPass</span><span class="hljs-params">(String inputPass, String salt)</span>&#123;<br>        <span class="hljs-comment">//第一次加密</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">formPass</span> <span class="hljs-operator">=</span> inputPassToFormPass(inputPass);<br>        <span class="hljs-comment">//第二次加密</span><br>        <span class="hljs-keyword">return</span> formPassToDBPass(formPass, salt);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试一下</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//b6f500ed7576bf832f970eb71479667c</span><br>        System.out.println(inputPassToFormPass(<span class="hljs-string">&quot;123456&quot;</span>));<br>        System.out.println(formPassToDBPass(<span class="hljs-string">&quot;b6f500ed7576bf832f970eb71479667c&quot;</span>, <span class="hljs-string">&quot;asdfg1243&quot;</span>));<br>        System.out.println(inputPassToDBPass(<span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;asdfg1243&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Cookies工具类"><a href="#Cookies工具类" class="headerlink" title="Cookies工具类"></a>Cookies工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CookieUtil</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到Cookie的值, 不编码</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName 名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getCookieValue</span><span class="hljs-params">(HttpServletRequest request, String cookieName)</span> &#123;<br>        <span class="hljs-keyword">return</span> getCookieValue(request, cookieName, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到Cookie的值，根据isDecode判断是否解码</span><br><span class="hljs-comment">     * 默认解码格式为utf-8</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName 名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isDecoder  是否解码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getCookieValue</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                        String cookieName,</span><br><span class="hljs-params">                                        <span class="hljs-type">boolean</span> isDecoder)</span> &#123;<br>        Cookie[] cookieList = request.getCookies();<br>        <span class="hljs-keyword">if</span> (cookieList == <span class="hljs-literal">null</span> || cookieName == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">retValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//遍历cookies开始查找</span><br>            <span class="hljs-keyword">for</span> (Cookie cookie : cookieList) &#123;<br>                <span class="hljs-keyword">if</span> (cookie.getName().equals(cookieName)) &#123;<br>                    <span class="hljs-keyword">if</span> (isDecoder) &#123;<br>                        retValue = URLDecoder.decode(cookie.getValue(),<br>                                <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        retValue = cookie.getValue();<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> retValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到Cookie的值，可指定解码格式</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName   名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> encodeString 解码格式</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getCookieValue</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                        String cookieName,</span><br><span class="hljs-params">                                        String encodeString)</span> &#123;<br>        Cookie[] cookieList = request.getCookies();<br>        <span class="hljs-keyword">if</span> (cookieList == <span class="hljs-literal">null</span> || cookieName == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">retValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Cookie cookie : cookieList) &#123;<br>                <span class="hljs-keyword">if</span> (cookie.getName().equals(cookieName)) &#123;<br>                    retValue = URLDecoder.decode(cookie.getValue(),<br>                            encodeString);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> retValue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName  名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieValue 需要设置的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCookie</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                 HttpServletResponse response,</span><br><span class="hljs-params">                                 String cookieName,</span><br><span class="hljs-params">                                 String cookieValue)</span> &#123;<br>        setCookie(request, response, cookieName, cookieValue, -<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置Cookie的值 在指定时间内生效,但不编码</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName   名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieValue  需要设置的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieMaxage 生效时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCookie</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                 HttpServletResponse response,</span><br><span class="hljs-params">                                 String cookieName,</span><br><span class="hljs-params">                                 String cookieValue,</span><br><span class="hljs-params">                                 <span class="hljs-type">int</span> cookieMaxage)</span> &#123;<br>        setCookie(request, response, cookieName, cookieValue, cookieMaxage,<br>                <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置Cookie的值 不设置生效时间,可以选择是否编码</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName  名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieValue 设置值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isEncode    是否编码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCookie</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                 HttpServletResponse response,</span><br><span class="hljs-params">                                 String cookieName,</span><br><span class="hljs-params">                                 String cookieValue,</span><br><span class="hljs-params">                                 <span class="hljs-type">boolean</span> isEncode)</span> &#123;<br>        setCookie(request, response, cookieName, cookieValue, -<span class="hljs-number">1</span>, isEncode);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置Cookie的值 在指定时间内生效, 编码参数</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName   名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieValue  设置值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieMaxage 生效时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isEncode     是否编码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCookie</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                 HttpServletResponse response,</span><br><span class="hljs-params">                                 String cookieName,</span><br><span class="hljs-params">                                 String cookieValue,</span><br><span class="hljs-params">                                 <span class="hljs-type">int</span> cookieMaxage,</span><br><span class="hljs-params">                                 <span class="hljs-type">boolean</span> isEncode)</span> &#123;<br>        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName   名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieValue  设置值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieMaxage 生效时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> encodeString 编码格式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCookie</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                 HttpServletResponse response,</span><br><span class="hljs-params">                                 String cookieName,</span><br><span class="hljs-params">                                 String cookieValue,</span><br><span class="hljs-params">                                 <span class="hljs-type">int</span> cookieMaxage,</span><br><span class="hljs-params">                                 String encodeString)</span> &#123;<br>        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除Cookie带cookie value</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName 名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteCookie</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                    HttpServletResponse response,</span><br><span class="hljs-params">                                    String cookieName)</span> &#123;<br>        doSetCookie(request, response, cookieName, <span class="hljs-string">&quot;&quot;</span>, -<span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置Cookie的值，并使其在指定时间内生效</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName   名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieValue  设置值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieMaxage 生效时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isEncode     是否编码</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSetCookie</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                          HttpServletResponse response,</span><br><span class="hljs-params">                                          String cookieName,</span><br><span class="hljs-params">                                          String cookieValue,</span><br><span class="hljs-params">                                          <span class="hljs-type">int</span> cookieMaxage,</span><br><span class="hljs-params">                                          <span class="hljs-type">boolean</span> isEncode)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (cookieValue == <span class="hljs-literal">null</span>) &#123;<br>                cookieValue = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isEncode) &#123;<br>                cookieValue = URLEncoder.encode(cookieValue, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(cookieName, cookieValue);<br>            <span class="hljs-keyword">if</span> (cookieMaxage &gt; <span class="hljs-number">0</span>) &#123;<br>                cookie.setMaxAge(cookieMaxage);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != request) &#123;<span class="hljs-comment">// 设置域名的cookie</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">domainName</span> <span class="hljs-operator">=</span> getDomainName(request);<br>                System.out.println(domainName);<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;localhost&quot;</span>.equals(domainName)) &#123;<br>                    cookie.setDomain(domainName);<br>                &#125;<br>            &#125;<br>            cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);<br>            response.addCookie(cookie);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置Cookie的值，并使其在指定时间内生效</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieName 名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieValue 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cookieMaxage 有效时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> encodeString 编码格式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSetCookie</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                                          HttpServletResponse response,</span><br><span class="hljs-params">                                          String cookieName,</span><br><span class="hljs-params">                                          String cookieValue,</span><br><span class="hljs-params">                                          <span class="hljs-type">int</span> cookieMaxage,</span><br><span class="hljs-params">                                          String encodeString)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (cookieValue == <span class="hljs-literal">null</span>) &#123;<br>                cookieValue = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cookieValue = URLEncoder.encode(cookieValue, encodeString);<br>            &#125;<br>            <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(cookieName, cookieValue);<br>            <span class="hljs-keyword">if</span> (cookieMaxage &gt; <span class="hljs-number">0</span>) &#123;<br>                cookie.setMaxAge(cookieMaxage);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != request) &#123;<span class="hljs-comment">// 设置域名的cookie</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">domainName</span> <span class="hljs-operator">=</span> getDomainName(request);<br>                System.out.println(domainName);<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;localhost&quot;</span>.equals(domainName)) &#123;<br>                    cookie.setDomain(domainName);<br>                &#125;<br>            &#125;<br>            cookie.setPath(<span class="hljs-string">&quot;/&quot;</span>);<br>            response.addCookie(cookie);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 得到cookie的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">getDomainName</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">domainName</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 通过request对象获取访问的url地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">serverName</span> <span class="hljs-operator">=</span> request.getRequestURL().toString();<br>        <span class="hljs-keyword">if</span> (serverName == <span class="hljs-literal">null</span> || serverName.equals(<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            domainName = <span class="hljs-string">&quot;&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 将url转换为小写</span><br>            serverName = serverName.toLowerCase();<br>            <span class="hljs-comment">// 如果url地址是以http://开头 将http://截取</span><br>            <span class="hljs-keyword">if</span> (serverName.startsWith(<span class="hljs-string">&quot;http://&quot;</span>)) &#123;<br>                serverName = serverName.substring(<span class="hljs-number">7</span>);<br>            &#125;<br>            <span class="hljs-comment">//截取后的长度</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> serverName.length();<br>            <span class="hljs-comment">// 判断url地址是否包含&quot;/&quot;</span><br>            <span class="hljs-keyword">if</span> (serverName.contains(<span class="hljs-string">&quot;/&quot;</span>)) &#123;<br>                <span class="hljs-comment">//得到第一个&quot;/&quot;出现的位置</span><br>                end = serverName.indexOf(<span class="hljs-string">&quot;/&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">// 截取</span><br>            serverName = serverName.substring(<span class="hljs-number">0</span>, end);<br>            <span class="hljs-comment">// 根据&quot;.&quot;进行分割</span><br>            <span class="hljs-keyword">final</span> String[] domains = serverName.split(<span class="hljs-string">&quot;\\.&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> domains.length;<br>            <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">3</span>) &#123;<br>                <span class="hljs-comment">// www.xxx.com.cn</span><br>                domainName = domains[len - <span class="hljs-number">3</span>] + <span class="hljs-string">&quot;.&quot;</span> + domains[len - <span class="hljs-number">2</span>] + <span class="hljs-string">&quot;.&quot;</span> +<br>                        domains[len - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span> &amp;&amp; len &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// xxx.com or xxx.cn</span><br>                domainName = domains[len - <span class="hljs-number">2</span>] + <span class="hljs-string">&quot;.&quot;</span> + domains[len - <span class="hljs-number">1</span>];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                domainName = serverName;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (domainName != <span class="hljs-literal">null</span> &amp;&amp; domainName.indexOf(<span class="hljs-string">&quot;:&quot;</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>            String[] ary = domainName.split(<span class="hljs-string">&quot;:&quot;</span>);<br>            domainName = ary[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> domainName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="电话号码校验工具类"><a href="#电话号码校验工具类" class="headerlink" title="电话号码校验工具类"></a>电话号码校验工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValidatorUtil</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 电话号码正则</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">MOBILE_PATTERN</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;[1]([3-9])[0-9]&#123;9&#125;$&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMobile</span><span class="hljs-params">(String mobile)</span>&#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(mobile)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> MOBILE_PATTERN.matcher(mobile);<br>        <span class="hljs-keyword">return</span> matcher.matches();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>工具类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类加载机制</title>
    <link href="/2021/01/31/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/01/31/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<div align="center">    <img src="/2021/01/31/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1.png" class=""></div><br><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>在对象的创建过程中，完成了检查阶段</p><div align="center">    <img src="/2021/01/31/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/2.png" class=""></div><br><ol><li>加载 （Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化 （Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ol><p>其中验证、准备、解析三个部分统称为连接（Linking）</p><p>其中加载、验证、准备、解析、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始。</p><p>而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始， 这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</p><p><strong>注意：</strong><br>这里笔者写的是 按部就班地“开始”，而不是按部就班地“进行”或按部就班地“完成”，强调这点是因为这些阶段通常都 是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。</p><p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段 尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部 分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><h2 id="第一个阶段——加载"><a href="#第一个阶段——加载" class="headerlink" title="第一个阶段——加载"></a>第一个阶段——加载</h2><ol><li>通过一个<strong>类的全限定名</strong>来获取定义此类的<strong>二进制字节流</strong>。</li><li>将这个<strong>字节流所代表的静态存储结构</strong>转化为<strong>方法区的运行时数据结构</strong>。</li><li>在内存中生成一个<strong>代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的<strong>访问入口</strong>。</li></ol><div align="center">    <img src="/2021/01/31/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/3.png" class=""></div><br><h2 id="第二个阶段——验证"><a href="#第二个阶段——验证" class="headerlink" title="第二个阶段——验证"></a>第二个阶段——验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是<strong>保证Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求</strong>，保证这些信息<strong>被当作代码运行后不会危害虚拟机自身的安全</strong></p><p>验证内容主要包含如下四点：</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><h2 id="第三个阶段——准备"><a href="#第三个阶段——准备" class="headerlink" title="第三个阶段——准备"></a>第三个阶段——准备</h2><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）**<strong>*<em><strong>分配内存</strong>并</em>*设置类变量初始值</strong>（对象创建过程的隐式创建）的阶段</p><p>假设一个类变量的定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><p>那变量value在准备阶段过后的初始值为<code>0</code>而不是<code>123</code>，因为这时尚未开始执行任何Java方法，而把 value赋值为<code>123</code>的 <code>putstatic</code> 指令是程序被编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中，所以把value赋值 为123的动作要到<strong>类的初始化阶段</strong>才会被执行</p><h2 id="第四个阶段——解析"><a href="#第四个阶段——解析" class="headerlink" title="第四个阶段——解析"></a>第四个阶段——解析</h2><p>解析阶段是Java虚拟机将<strong>常量池内的符号引用</strong>替换为<strong>直接引用</strong>的过程</p><h2 id="第五个阶段——初始化"><a href="#第五个阶段——初始化" class="headerlink" title="第五个阶段——初始化"></a>第五个阶段——初始化</h2><p>类的初始化阶段是类加载过程的最后一个步骤，初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程</p><p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态语句块（<code>static&#123;&#125;</code>块）中的语句</strong>合并产生的</p><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>在类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。</p><p>而实现这个动作的代码被称为“类加载器”（Class Loader）</p><h2 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h2><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却**<strong>远超类加载阶段</strong>。</p><p>对于 任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p>这句话表达地更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</strong></p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap Class Loader），另外一种就是其他所有的类加载器。</p><h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p><code>Bootstrap Class Loader</code></p><p>这个类加载器使用C++语言实现，是虚拟机的一部分。</p><p>负责加载存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录，或者被<code>-Xbootclasspath</code>参数所指定的路径中存放的，而且是Java虚拟机能够识别的类库</p><h3 id="其他所有的类加载器"><a href="#其他所有的类加载器" class="headerlink" title="其他所有的类加载器"></a>其他所有的类加载器</h3><p>这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code></p><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><p>Extension Class Loader</p><p>这个类加载器是在类<code>sun.misc.Launcher$ExtClassLoade</code>r中以Java代码的形式实现的。</p><p>主要负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中，或者被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库。</p><p>顾名思义，它是一种Java系统类库的扩展机制。用户可以将具有通用性的类库存放至ext目录里来扩展Java SE的功能</p><h4 id="应用程序类加载器"><a href="#应用程序类加载器" class="headerlink" title="应用程序类加载器"></a>应用程序类加载器</h4><p><code>Application Class Loader</code></p><p>这个类加载器是在类<code>sun.misc.Launcher$AppClassLoader</code>中以Java代码的形式实现的。</p><p>主要负责加载用户类路径上所有的类库</p><h3 id="互相配合"><a href="#互相配合" class="headerlink" title="互相配合"></a>互相配合</h3><p>在JDK 9之前的Java应用都是由这三种类加载器互相配合来完成加载的，而各种类加载器之间的层次关系被称之为类加载器的“双亲委派模型”</p><div align="center">    <img src="/2021/01/31/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/4.png" class=""></div><br><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。</p><p>例如类<code>java.lang.Object</code>，它存放在<code>rt.jar</code>之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</p><p>如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为<code>java.lang.Object</code>的类，并放在程序的<code>ClassPath</code>中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-type">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;<br>    <span class="hljs-comment">// 首先，检查请求的类是否已经被加载过了</span><br>    <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> findLoadedClass(name);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>                c = parent.loadClass(name, <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                c = findBootstrapClassOrNull(name);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e)&#123;<br>            <span class="hljs-comment">// 如果父类加载器抛出ClassNotFoundException</span><br>            <span class="hljs-comment">// 说明父类加载器无法完成加载请求</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">// 在父类加载器无法加载时</span><br>            <span class="hljs-comment">// 再调用本身的findClass方法来进行类加载</span><br>            c = findClass(name);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (resolve) &#123;<br>        resolveClass(c);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾收集</title>
    <link href="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/"/>
    <url>/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>很多教科书判断对象是否存活的算法是这样的：</p><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。</p><p>基本思路就是通过一系列称为“<code>GC Roots</code>”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为<br>“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/1.png" class=""></div><br><h2 id="GC-Roots对象"><a href="#GC-Roots对象" class="headerlink" title="GC Roots对象"></a>GC Roots对象</h2><ul><li>在<strong>虚拟机栈</strong>（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li><li>方法区中<strong>类静态属性</strong>引用的对象，譬如Java类的引用类型静态变量</li><li>方法区中<strong>常量</strong>引用的对象，譬如字符串常量池（String Table）里的引用</li><li>本地方法栈中<strong>JNI（Native方法）</strong>引用的对象<br>Java<strong>虚拟机内部</strong>引用的对象，譬如基本数据类型对应的Class对象，常驻的异常对象，系统类加载器</li><li>所有被<strong>同步锁</strong>（synchronized关键字）持有的对象</li><li><strong>反应Java虚拟机内部情况</strong>的对象，譬如JMXBean、JVMTI中注册的回调、本地代码缓存等</li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li>强引用，类似<strong>Object obj &#x3D; new Object()这种引用关系，只要强引用关系存在，垃圾收集器就永远不会收掉被引用的对象</strong></li><li>软引用，有用，但非必须的对象。在系统将要<strong>发生内存溢出异常前</strong>，会把这些对象列进回收范围之中<strong>进行第二次回收</strong></li><li>弱引用，描述那些非必须对象，但是它的强度比软引用更弱一些，<strong>每次都会被垃圾收集器收集</strong></li><li>虚引用，最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。唯一目的只是为了能在这个对象<strong>被收集器回收时收到一个系统通知</strong></li></ul><h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p><p>如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那它将会被第一次标记，</p><p>随后进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。</p><p>假如对象没有覆盖<code>finalize()</code>方法(无药可救)，或者<code>finalize()</code>方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（ReferenceCounting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。</p><p>由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不把它作为正文主要内容来讲解，本节介绍的所有算法均属于追踪式垃圾收集的范畴。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>部分收集<code>（Partial GC）</code>：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：</li><li>新生代收集<code>（Minor GC/Young GC）</code>：指目标只是新生代的垃圾收集。</li><li>老年代收集<code>（Major GC/Old GC）</code>：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li><li>混合收集<code>（Mixed GC）</code>：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li><li>整堆收集<code>（Full GC）</code>：收集整个Java堆和方法区的垃圾收集。</li></ul><h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/2.png" class=""></div><br><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>速度非常快</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低</li><li>容易产生内存碎片，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br>比如上图中有一块较大的对象想存放，但是存放不下</li></ol><h2 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h2><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/3.png" class=""></div><br><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>老年代</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>没有内存碎片</p><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>添加了一步整理的过程，需要移动对象，速度相对较慢</p><h2 id="标记复制算法"><a href="#标记复制算法" class="headerlink" title="标记复制算法"></a>标记复制算法</h2><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/4.png" class=""></div><br><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/5.png" class=""></div><br><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/6.png" class=""></div><br><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/7.png" class=""></div><br><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>现在的商用Java虚拟机大多都优先采用了复制收集算法去回收新生代；但不适用于老年代，因为存活率高，会有较多的复制操作，效率将会降低</p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>不会产生内存碎片，速度也相对较快</p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>占用双倍的内存空间</p><h1 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h1><h2 id="Java堆内存"><a href="#Java堆内存" class="headerlink" title="Java堆内存"></a>Java堆内存</h2><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/8.png" class=""></div><br><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>使用<code>Minor GC/Young GC</code>，标记-复制算法</p><h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>使用<code>Major GC/Old GC</code>，标记-整理算法</p><h1 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h1><h2 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h2><p><code>“Stop The World”</code>这个词语也许听起来很酷，但这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的。</p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK 1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择。</p><p>是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p><p>写到这里，笔者似乎已经把Serial收集器描述成一个最早出现，但目前已经老而无用，食之无味，弃之可惜的“鸡肋”了，但事实上，迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的</p><p>在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代（仅仅是指新生代使用的内存，桌面应用甚少超过这个容量），垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。所以，Serial收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。</p><h3 id="运行示意图"><a href="#运行示意图" class="headerlink" title="运行示意图"></a>运行示意图</h3><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/9.png" class=""></div><br><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p><h3 id="运行示意图-1"><a href="#运行示意图-1" class="headerlink" title="运行示意图"></a>运行示意图</h3><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/10.png" class=""></div><br><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器实质上是Serial收集器的多线程并行版本</p><p>ParNew收集器除了支持多线程并行收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是不少运行在服务端模式下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中首选的新生代收集器，其中有一个与功能、性能无关但其实很重要的原因是：</p><p>除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p>自JDK 9开始，ParNew加CMS收集器的组合就不再是官方 推荐的服务端模式下的收集器解决方案了</p><h3 id="运行示意图-2"><a href="#运行示意图-2" class="headerlink" title="运行示意图"></a>运行示意图</h3><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/11.png" class=""></div><br><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>并行和并发都是并发编程中的专业名词，在谈论垃圾收集器的上下文语境中，它们可以理解为：</p><ul><li><p>并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。</p></li><li><p>并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。</p></li></ul><p>由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。</p><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p><code>Parallel Scavenge</code>收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器……</p><p><code>Parallel Scavenge</code>的诸多特性从表面上看和<code>ParNew</code>非常相似</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>达到一个可控制的吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值</p><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/12.png" class=""></div><br><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul><li>控制最大垃圾收集停顿时间的<code>-XX：MaxGCPauseMillis</code></li><li>直接设置吞吐量大小的<code>-XX：GCTimeRatio</code></li><li>自适应的调节策略<code>-XX：+UseAdaptiveSizePolicy</code></li></ul><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p><code>Parallel Old</code>是<code>Parallel Scavenge</code>收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。</p><h3 id="运行示意图-3"><a href="#运行示意图-3" class="headerlink" title="运行示意图"></a>运行示意图</h3><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/13.png" class=""></div><br><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p><code>CMS（Concurrent Mark Sweep）</code>收集器是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现</p><p>目前很大一部分的Java应用集中在互联网网站或者基于浏览器的<code>B/S</code>系统的服务端上，这类应用通常都会较为 关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>以获取最短回收停顿时间为目标的收集器</p><h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><ol><li>初始标记<br> 会触发STW，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快</li><li>并发标记<br> 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</li><li>重新标记<br> 会触发STW，是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li><li>并发清除<br> 清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ol><h3 id="运行示意图-4"><a href="#运行示意图-4" class="headerlink" title="运行示意图"></a>运行示意图</h3><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/14.png" class=""></div><br><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ol><li>CMS收集器对处理器资源非常敏感。</li><li>CMS收集器无法处理“浮动垃圾”<code>（Floating Garbage）</code></li><li>CMS是一款基于“标记-清除”算法实现的收集器，缺点非常明显，一是不稳定，二是有垃圾碎片</li></ol><h2 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h2><p>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p><p>G1是一款主要面向服务端应用的垃圾收集器。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>同时注重吞吐量和低延迟，默认暂停目标 200ms</li><li>超大堆内存，会将堆划分为多个大小相等的Region</li><li>整体上是标记+整理算法，两个区域之间是复制算法</li></ul><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>首先要有一个思想上的改变，在G1收集器出现之前的所有 其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。</p><p>而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而 是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p><h3 id="TAMS"><a href="#TAMS" class="headerlink" title="TAMS"></a>TAMS</h3><p>G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</p><h3 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h3><p>原始快照</p><h3 id="运行过程-1"><a href="#运行过程-1" class="headerlink" title="运行过程"></a>运行过程</h3><ol><li><p>初始标记</p><p> 会触发STW，仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</p></li><li><p>并发标记</p><p> 从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。</p></li><li><p>最终标记</p><p> 会触发STW，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</p></li><li><p>筛选回收</p><p> 会触发STW，负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。</p></li></ol><h3 id="运行示意图-5"><a href="#运行示意图-5" class="headerlink" title="运行示意图"></a>运行示意图</h3><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/15.png" class=""></div><br><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/16.png" class=""></div><br><h4 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h4><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/17.png" class=""></div><br><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/18.png" class=""></div><br><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/19.png" class=""></div><br><h4 id="Young-Collection-Concurrent-Mark"><a href="#Young-Collection-Concurrent-Mark" class="headerlink" title="Young Collection + Concurrent Mark"></a>Young Collection + Concurrent Mark</h4><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/20.png" class=""></div><br><h4 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h4><div align="center">    <img src="/2021/01/30/JVM/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86/21.png" class=""></div><br><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">-XX: +UseG1GC<br>-xx: G1HeapRegionSize = size<br>-xx: MaxGCPauseMillis = time<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象的创建过程</title>
    <link href="/2021/01/30/JVM/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/01/30/JVM/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一、检查"><a href="#一、检查" class="headerlink" title="一、检查"></a>一、检查</h1><ol><li>检查指令的参数是否能在常量池中定位到一个类的符号引用</li><li>检查这个符号引用代表的类是否已被加载、解析和初始化过</li><li>类加载检查是否符合《Java虚拟机规范》的全部约束要求</li></ol><h1 id="二、分配内存"><a href="#二、分配内存" class="headerlink" title="二、分配内存"></a>二、分配内存</h1><p>1.选择分配方式。</p><pre><code class="hljs">Java堆中的内存如果是绝对规整的，将会采用“指针碰撞”的分配方式；反之采用“空闲列表”的分配方式。而Java堆中的内存是否规整又采用的垃圾收集器是否带有空间压缩整理的能力决定。因此使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高校。使用CMS这种基于清除算法的收集器时，采用比较复杂的空闲列表来分配内存</code></pre><p>2.因为创建对象是虚拟机中非常频繁的行为，要解决线程问题。</p><pre><code class="hljs">虚拟机提供了两种解决方案：一种是采用CAS配上失败重试的方式保证更新操作的原子性；另一种是为每个线程在Java堆中预先分配一块内存，称为本地线程分配缓存(Thread Local Allocation Buffer, TLAB)</code></pre><h1 id="三、初始化"><a href="#三、初始化" class="headerlink" title="三、初始化"></a>三、初始化</h1><ol><li><p>隐式初始化。</p><p> 虚拟机将分配到不包括对象头在内的内存空间初始化为0，如果这分配内存时采用TLAB解决线程安全问题，那么这一步会提前至TLAB分配时顺便进行。</p></li><li><p>显示初始化。</p><p> 虚拟机为对象头进行必要的设置，<br> 例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。<br> 从虚拟机的视角来看，一个新的对象已经产生了。</p></li><li><p>执行<code>&lt;init&gt;()</code>方法，按照开发者的意愿对对象进行初始化，此时一个真正可用的对象才算完全被构造出来。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTPS</title>
    <link href="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/"/>
    <url>/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。</li><li>HTTPS 经由 HTTP 进行通信，但利用 <strong>SSL&#x2F;TLS 来加密数据包</strong>。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</li></ul><h2 id="与HTTP的对比"><a href="#与HTTP的对比" class="headerlink" title="与HTTP的对比"></a>与HTTP的对比</h2><h3 id="默认端口"><a href="#默认端口" class="headerlink" title="默认端口"></a>默认端口</h3><ul><li>HTTPS 默认工作在 TCP 协议443端口</li><li>HTTP 默认工作在 TCP 协议 80 端口</li></ul><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><ul><li>HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好</li><li>HTTP 明文传输，数据都是未加密的，安全性较差</li></ul><h3 id="协议证书"><a href="#协议证书" class="headerlink" title="协议证书"></a>协议证书</h3><ul><li>使用 HTTPS 协议需要到** CA（Certificate Authority，数字证书认证机构）** 申请证书，一般免费证书较少，因而需要一定费用。</li><li>HTTP不用</li></ul><h3 id="响应速度"><a href="#响应速度" class="headerlink" title="响应速度"></a>响应速度</h3><ul><li>HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包</li><li>HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包</li></ul><h3 id="资源消耗"><a href="#资源消耗" class="headerlink" title="资源消耗"></a>资源消耗</h3><ul><li>HTTPS因为要加上ssl握手需要的包，所以会根据消耗资源</li><li>HTTP不需要ssl握手</li></ul><h3 id="握手过程对比"><a href="#握手过程对比" class="headerlink" title="握手过程对比"></a>握手过程对比</h3><h4 id="HTTPS-1"><a href="#HTTPS-1" class="headerlink" title="HTTPS"></a>HTTPS</h4><div align="center"><img src="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/1.gif" class=""></div><ol><li>客户端发送请求https连接。</li><li>服务器返回加密公钥，通常是SSL证书。</li><li>客户端从这个SSL证书解析出公钥，并随机生成一个key，通过公钥加密这个key发送给服务器（这一步是安全的因为只有服务器才有私钥能读出这个key）。</li><li>服务器通过私钥解密出key。</li><li>客户端使用这个key来加密需要传输的数据。</li><li>服务器使用key来解析数据。</li></ol><p>简单的来说SSL加密的方式是使用一个密钥来加密另一个密钥（key），在使用被加密的密钥来加密数据。<br>这样的做法固然保证了安全性，但每次连接时都需要使用密钥加密，导致请求会需要额外的开销，同时服务器第一次返回的公钥的可靠性需要第三方来保证，通常是购买SSL证书。这也会造成额外的经济开销。</p><h5 id="1、客户端发起-HTTPS-请求"><a href="#1、客户端发起-HTTPS-请求" class="headerlink" title="1、客户端发起 HTTPS 请求"></a>1、客户端发起 HTTPS 请求</h5><p>这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</p><h5 id="2、服务端的配置"><a href="#2、服务端的配置" class="headerlink" title="2、服务端的配置"></a>2、服务端的配置</h5><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。</p><p>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p><h5 id="3、传送证书"><a href="#3、传送证书" class="headerlink" title="3、传送证书"></a>3、传送证书</h5><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><h5 id="4、客户端解析证书"><a href="#4、客户端解析证书" class="headerlink" title="4、客户端解析证书"></a>4、客户端解析证书</h5><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p><p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p><h5 id="5、传送加密信息"><a href="#5、传送加密信息" class="headerlink" title="5、传送加密信息"></a>5、传送加密信息</h5><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><h5 id="6、服务端解密信息"><a href="#6、服务端解密信息" class="headerlink" title="6、服务端解密信息"></a>6、服务端解密信息</h5><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><h5 id="7、传输加密后的信息"><a href="#7、传输加密后的信息" class="headerlink" title="7、传输加密后的信息"></a>7、传输加密后的信息</h5><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><h5 id="8、客户端解密信息"><a href="#8、客户端解密信息" class="headerlink" title="8、客户端解密信息"></a>8、客户端解密信息</h5><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><div align="center"><img src="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS/2.jpg" class=""></div><h5 id="1、第一次握手"><a href="#1、第一次握手" class="headerlink" title="1、第一次握手"></a>1、第一次握手</h5><p>客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn&#x3D;j，客户端进入 SYN_SEND 状态等待服务器确认</p><h5 id="2、第二次握手"><a href="#2、第二次握手" class="headerlink" title="2、第二次握手"></a>2、第二次握手</h5><p>服务器接收客户端syn包并确认（ack&#x3D;j+1），同时向客户端发送一个 SYN包（syn&#x3D;k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态</p><h5 id="3、第三次握手"><a href="#3、第三次握手" class="headerlink" title="3、第三次握手"></a>3、第三次握手</h5><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/"/>
    <url>/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><h2 id="HTTP请求报文格式"><a href="#HTTP请求报文格式" class="headerlink" title="HTTP请求报文格式"></a>HTTP请求报文格式</h2><center><img src="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/1.png" class=""></center><h3 id="请求行支持的方法"><a href="#请求行支持的方法" class="headerlink" title="请求行支持的方法"></a>请求行支持的方法</h3><center><img src="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/2.png" class=""></center><h2 id="HTTP响应报文格式"><a href="#HTTP响应报文格式" class="headerlink" title="HTTP响应报文格式"></a>HTTP响应报文格式</h2><center><img src="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/3.png" class=""></center><h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ul><li>100：这个状态码是告诉客户端<strong>应该继续发送请求</strong>，这个临时响应是用来<strong>通知客户端的，部分的请求服务器已经接受</strong>，但是客户端应继续发送求请求的剩余部分，如果请求已经完成，就忽略这个响应，而且服务器会在请求完成后向客户发送一个最终的结果</li><li>200：这个是最常见的http状态码，表示服务器<strong>已经成功接受请求，并将返回客户端所请求的最终结果</strong></li><li>202：表示服务器已经接受了请求，但是<strong>还没有处理</strong>，而且这个请求最终会不会<strong>处理还不确定</strong></li><li>204：服务器成功<strong>处理了请求，但没有返回任何实体内容</strong> ，可能会返回新的头部元信息</li><li>301：客户端请求的网页<strong>已经永久移动到新的位置</strong>，当链接发生变化时，返回301代码<strong>告诉客户端链接的变化</strong>，客户端保存新的链接，并向新的链接发出请求，已返回请求结果</li><li>404：请求失败，客户端请求的资源<strong>没有找到或者是不存在</strong></li><li>500：服务器遇到未知的错误，导致无法完成客户端当前的请求</li><li>503：服务器由于临时的服务器<strong>过载或者是维护</strong>，无法解决当前的请求</li></ul><h2 id="请求和响应报文的对比"><a href="#请求和响应报文的对比" class="headerlink" title="请求和响应报文的对比"></a>请求和响应报文的对比</h2><center><img src="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/4.png" class=""></center><h2 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h2><p><strong>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接</strong></p><p>当一个网页文件中包含了很多图像的地址的时候，那就需要很多次的http请求和响应，每次请求和响应都需要一个单独的连接，每次连接只是传输一个文档和图像，上一次和下一次请求完全分离。</p><p>即使图像文件都很小，但是客户端和服务器端每次建立和关闭连接却是一个相对比较费时的过程，并且会严重影响客户机和服务器的性能。当一个网页文件中包含JavaScript文件，CSS文件等内容时，也会出现类似上述的情况。</p><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><ul><li>HTTP&#x2F;1.0采用非持续连接方式。</li><li>在该方式下，每次浏览器要请求一个文件都要与服务器建立TCP连接，当收到响应后就立即关闭连接<center></li></ul><img src="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/5.png" class=""></center><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>每次请求都需要有两倍的<strong>RTT（请求和响应所花费的时间，往返时延，Round-Trip Time）</strong></li><li>为了减少时延，<strong>浏览器通常会建立多个并行的TCP连接同时请求多个对象</strong>。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务大量客户的请求，这会使其负担很重</li></ul><h2 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h2><p>为了<strong>克服HTTP 1.0的这个缺陷</strong>，HTTP 1.1支持持久连接（HTTP&#x2F;1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。</p><p>一个包含有许多图像的网页文件的多个请求和应答可以在一个连接中传输，但每个单独的网页文件的请求和应答仍然需要使用各自的连接。</p><p>HTTP 1.1还允许客户端<strong>不用等待上一次请求结果返回，就可以发出下一次请求</strong>，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，这样也显著地减少了整个下载过程所需要的时间。</p><p>在HTTP 1.1，request和response头中都有可能出现一个connection的头，此header的含义是当client和server通信时对于长链接如何进行处理。</p><p>在HTTP 1.1中，<strong>client和server都是默认对方支持长链接</strong>的， 如果client使用HTTP 1.1协议，但又不希望使用长链接，则需要在header中指明connection的值为close；如果server方也不想支持长链接，则在response中也需要明确说明connection的值为close。</p><p>不论request还是response的header中包含了值为close的connection，都表明当前正在使用的TCP链接在当天请求处理完毕后会被断掉。以后client再进行新的请求时就必须创建新的TCP链接了。</p><p>HTTP 1.1在继承了HTTP 1.0优点的基础上，也克服了HTTP 1.0的性能问题。</p><p>HTTP 1.1通过增加更多的请求头和响应头来改进和扩充HTTP 1.0的功能。如，HTTP 1.0不支持Host请求头字段，WEB浏览器无法使用主机头名来明确表示要访问服务器上的哪个WEB站点，这样就无法使用WEB服务器在同一个IP地址和端口号上配置多个虚拟WEB站点。在HTTP 1.1中增加Host请求头字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。</p><p>HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为close时，客户端通知服务器返回本次请求结果后关闭连接。HTTP 1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头。HTTP&#x2F;1.0不支持文件断点续传，RANGE:bytes是HTTP&#x2F;1.1新增内容，HTTP&#x2F;1.0每次传送文件都是从文件头开始，即0字节处开始。RANGE:bytes&#x3D;XXXX表示要求服务器从文件XXXX字节处开始传送，这就是我们平时所说的断点续传！</p><h3 id="连接方式-1"><a href="#连接方式-1" class="headerlink" title="连接方式"></a>连接方式</h3><ul><li>HTTP&#x2F;1.1采用持续连接方式</li><li>在该方式下，万维网服务器在发送响应后仍然保留这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传输后续的HTTP请求报文和响应报文</li><li>不局限于传输同一个页面上的引用对象，而是只要这些文档都在同一个服务器上就行</li></ul><center><img src="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6.png" class=""></center><h2 id="HTTP-1-0和HTTP-1-1的区别"><a href="#HTTP-1-0和HTTP-1-1的区别" class="headerlink" title="HTTP 1.0和HTTP 1.1的区别"></a>HTTP 1.0和HTTP 1.1的区别</h2><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><ul><li>HTTP 1.1<strong>支持长连接和请求的流水线处理</strong>，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，并**<strong>且默认开启长连接keep-alive</strong>，一定程度上弥补了HTTP 1.0每次请求都要创建连接的缺点。</li><li>HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。</li></ul><h3 id="节约带宽"><a href="#节约带宽" class="headerlink" title="节约带宽"></a>节约带宽</h3><ul><li>HTTP 1.1<strong>支持只发送header信息（不带任何body信息）</strong>，如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以<strong>不用发送请求body了节约了带宽</strong>。</li><li>HTTP 1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将<strong>整个对象送过来了，并且不支持断点续传功能</strong>。</li></ul><h3 id="HOST域"><a href="#HOST域" class="headerlink" title="HOST域"></a>HOST域</h3><ul><li>HTTP 1.1的请求消息和响应消息都支持host域，且请求消息中如果没有HOST域会报告一个错误（400 Bad Request）。</li><li>在HTTP 1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。</li></ul><h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><ul><li>HTTP 1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li>在HTTP 1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准</li></ul><h3 id="错误通知的管理"><a href="#错误通知的管理" class="headerlink" title="错误通知的管理"></a>错误通知的管理</h3><p>HTTP 1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><h2 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h2><p>相比 HTTP&#x2F;1.x，HTTP&#x2F;2 在底层传输做了很大的改动和优化：</p><h3 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h3><p>HTTP&#x2F;2 采用<strong>二进制格式</strong>传输数据，而非 HTTP&#x2F;1.x 的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。</p><h3 id="头部数据压缩"><a href="#头部数据压缩" class="headerlink" title="头部数据压缩"></a>头部数据压缩</h3><ul><li>HTTP&#x2F;2 <strong>对消息头采用 HPACK 进行压缩传输</strong>，能够节省消息头占用的网络的流量。而 HTTP&#x2F;1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。头压缩能够很好的解决该问题。</li><li>在HTTP 1.1中，HTTP请求和响应都是由状态行、请求&#x2F;响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。<br>随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。</li><li>HTTP 1.1不支持header数据的压缩，HTTP 2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</li></ul><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><ul><li>直白的说就是所有的请求都是通过一个TCP 连接并发完成。</li><li>HTTP&#x2F;1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用；也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</li><li>而 HTTP&#x2F;2 做到了真正的并发请求，而且并发请求的数量比HTTP 1.1大了好几个数量级。同时，流还支持优先级和流量控制。</li></ul><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>为了改善延迟，HTTP 2.0引入了server push，服务端能够更快的把资源推送给客户端。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求。当客户端需要的时候，它已经在客户端了。</p><center><img src="/2021/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/7.jpeg" class=""></center>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP和UDP</title>
    <link href="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/"/>
    <url>/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="一、TCP流量控制"><a href="#一、TCP流量控制" class="headerlink" title="一、TCP流量控制"></a>一、TCP流量控制</h2><h3 id="1-1-什么是流量控制有什么用？"><a href="#1-1-什么是流量控制有什么用？" class="headerlink" title="1.1 什么是流量控制有什么用？"></a>1.1 什么是流量控制有什么用？</h3><p>​如果数据发送的过快，则就接收方可能来不及接收，造成数据的丢失</p><p>​ 所谓流量控制就是<strong>让发送方的发送速率不要太快，让接收方来得及接收</strong>。</p><h3 id="1-2-滑动窗口实例"><a href="#1-2-滑动窗口实例" class="headerlink" title="1.2 滑动窗口实例"></a>1.2 滑动窗口实例</h3><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/1.png" class=""></center><h3 id="1-3-0窗口探测报文（携带1字节）"><a href="#1-3-0窗口探测报文（携带1字节）" class="headerlink" title="1.3 0窗口探测报文（携带1字节）"></a>1.3 0窗口探测报文（携带1字节）</h3><p>当接收方告知发送方法接收窗口为0的时候开始启动持续计时器，等待接收方缓存有了新的存储空间</p><p>​这个过程没过一个持续计时器都会发送零窗口探测报文</p><p><strong>TCP协议规定无论接收方的接收窗口为多大都需要接收0窗口探测报文</strong></p><p>发送0窗口探测报文也会有一个超时重传的机制</p><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/2.png" class=""></center><br><p><strong>宏观来讲</strong>：客户端的发送窗口由服务端的接收窗口决定，进而达到服务端对客户端的流量控制。当服务端的接收窗口为0时，客户端会开始启动持续计时器，每过一个持续计时器都会向服务端发送0窗口探测报文，目的是为了防止服务端有了新的存储空间向客户端重新发送接收窗口时却丢失造成死锁的情况。</p><h2 id="二、拥塞控制"><a href="#二、拥塞控制" class="headerlink" title="二、拥塞控制"></a>二、拥塞控制</h2><h3 id="2-1-什么是拥塞控制"><a href="#2-1-什么是拥塞控制" class="headerlink" title="2.1 什么是拥塞控制"></a>2.1 什么是拥塞控制</h3><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/3.png" class=""></center><ul><li><strong>ssthresh</strong>： 慢开始门限值</li><li><strong>cwnd</strong>： 拥塞窗口值</li></ul><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/4.png" class=""></center><h3 id="2-2-快恢复"><a href="#2-2-快恢复" class="headerlink" title="2.2 快恢复"></a>2.2 快恢复</h3><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/5.png" class=""></center><h3 id="2-3-TCP超时重传的选择"><a href="#2-3-TCP超时重传的选择" class="headerlink" title="2.3 TCP超时重传的选择"></a>2.3 TCP超时重传的选择</h3><p>超时时间的选择</p><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/6.png" class=""></center><h2 id="三、TCP可靠传输的实现"><a href="#三、TCP可靠传输的实现" class="headerlink" title="三、TCP可靠传输的实现"></a>三、TCP可靠传输的实现</h2><h3 id="3-1-如何描述发送窗口的状态"><a href="#3-1-如何描述发送窗口的状态" class="headerlink" title="3.1 如何描述发送窗口的状态"></a>3.1 如何描述发送窗口的状态</h3><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/7.png" class=""></center><h3 id="3-2-TCP传输过程中的特性"><a href="#3-2-TCP传输过程中的特性" class="headerlink" title="3.2 TCP传输过程中的特性"></a>3.2 TCP传输过程中的特性</h3><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/8.png" class=""></center><h2 id="四、TCP的运输连接管理"><a href="#四、TCP的运输连接管理" class="headerlink" title="四、TCP的运输连接管理"></a>四、TCP的运输连接管理</h2><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/9.png" class=""></center><h3 id="4-1-TCP的连接建立"><a href="#4-1-TCP的连接建立" class="headerlink" title="4.1 TCP的连接建立"></a>4.1 TCP的连接建立</h3><h4 id="4-1-1-连接建立的三个前提"><a href="#4-1-1-连接建立的三个前提" class="headerlink" title="4.1.1 连接建立的三个前提"></a>4.1.1 连接建立的三个前提</h4><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/10.png" class=""></center><h4 id="4-1-2-连接建立的具体过程"><a href="#4-1-2-连接建立的具体过程" class="headerlink" title="4.1.2 连接建立的具体过程"></a>4.1.2 连接建立的具体过程</h4><blockquote><p>TCP的标准规定: SYN&#x3D;1的报文段不能携带数据，但要消耗一个序号.</p><p>普通报文段不携带数据，则不需要消耗序号</p></blockquote><ul><li><strong>SYN</strong>：同步序列编号</li><li><strong>seq</strong>：序列编号</li><li><strong>ack</strong>：确认编号</li><li><strong>ACK</strong>：确认值，为1表示确认</li></ul><blockquote><p>TCP建立过程中，客户机首先发送一个SYN消息和一个seq，服务器使用SYN+ACK应答表示接收，最后客户机再以ACK消息响应。</p></blockquote><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/11.png" class=""></center><p>如果只有两次报文握手的情况</p><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/12.png" class=""></center><p><strong>两次报文握手不行:</strong><br>因为在网络情况下，可能第一个TCP连接请求报文段滞留在网络环境中，TCP连接请求发送重传，服务器和客户端成功建立连接之后释放连接，滞留在网络中的第一个TCP报文段送到了服务器，会导致服务器一致保持在连接建立的状态下，浪费服务器主机的进程资源.</p><p><strong>第三次报文的作用</strong>: 防止已经失效的tcp请求报文又突然传到了服务器，因而导致错误.</p><h2 id="五、TCP连接的释放-四报文挥手"><a href="#五、TCP连接的释放-四报文挥手" class="headerlink" title="五、TCP连接的释放(四报文挥手)"></a>五、TCP连接的释放(四报文挥手)</h2><p><strong>FIN：Finish结束标识</strong></p><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/13.png" class=""></center><p><strong>MSL为最长报文段寿命</strong></p><h3 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h3><center><img src="/2021/01/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/14.png" class=""></center><h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><table><thead><tr><th align="center"></th><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="center">是否面向连接</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">是否可靠</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">是否有状态</td><td align="center">是</td><td align="center">否</td></tr><tr><td align="center">传输效率</td><td align="center">较慢</td><td align="center">较快</td></tr><tr><td align="center">传输形式</td><td align="center">字节流</td><td align="center">数据报文段</td></tr><tr><td align="center">首部开销</td><td align="center">20 ～ 60 bytes</td><td align="center">8 bytes</td></tr><tr><td align="center">是否提供广播或多播服务</td><td align="center">否</td><td align="center">是</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>TCP</tag>
      
      <tag>UDP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL优化</title>
    <link href="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/"/>
    <url>/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容均为转载自<br><a href="https://www.bilibili.com/video/BV1kh411Y7vx?p=17&amp;&gt;">https://www.bilibili.com/video/BV1kh411Y7vx?p=17&amp;&gt;</a> spm_id_from&#x3D;pageDriver<br>的课程资料</p></blockquote><h1 id="一、SQL优化"><a href="#一、SQL优化" class="headerlink" title="一、SQL优化"></a>一、SQL优化</h1><p>SQL优化的目的是为了SQL语句能够具备优秀的查询性能，实现这样的目的有很多的途径：</p><ul><li>工程优化如何实现：数据库标准、表的结构标准、字段的标准、创建索引</li><li>SQL语句的优化：当前SQL语句有没有命中索引。</li></ul><h2 id="1-工程优化如何实现"><a href="#1-工程优化如何实现" class="headerlink" title="1.工程优化如何实现"></a>1.工程优化如何实现</h2><p>参考《MySQL军规升级版》</p><h2 id="2-Explain执行计划——SQL优化神器"><a href="#2-Explain执行计划——SQL优化神器" class="headerlink" title="2.Explain执行计划——SQL优化神器"></a>2.Explain执行计划——SQL优化神器</h2><p>得知道当前系统里有哪些SQL是慢SQL，查询性能超过1s的sql，然后再通过Explain工具可以对当前SQL语句的性能进行判断——为什么慢，怎么解决。</p><p>要想知道哪些SQL是慢SQL，有两种方式，一种是开启本地MySQL的慢查询日志；另一种是阿里云提供的RDS（第三方部署的MySQL服务器），提供了查询慢SQL的功能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> &quot;customer100%&quot;<br></code></pre></td></tr></table></figure><p>通过在SQL语句前面加上explain关键字，执行后并不会真正的执行sql语句本身，而是通过explain工具来分析当前这条SQL语句的性能细节：比如是什么样的查询类型、可能用到的索引及实际用到的索引，和一些额外的信息。</p><div align=center>    <img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210518092433386.png" class="" title="image-20210518092433386"></div><h2 id="3-MySQL的内部优化器"><a href="#3-MySQL的内部优化器" class="headerlink" title="3.MySQL的内部优化器"></a>3.MySQL的内部优化器</h2><p>在SQL查询开始之前，MySQL内部优化器会进行一次自我优化，让这一次的查询性能尽可能的好。</p><p>当前执行的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br><span class="hljs-keyword">show</span> warnings;<br></code></pre></td></tr></table></figure><p>内部优化器优化后的效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/* select#1 */</span> <span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">AS</span> `id`,<span class="hljs-string">&#x27;千锋Java厉害&#x27;</span> <span class="hljs-keyword">AS</span> `name` <span class="hljs-keyword">from</span> `db_mysql_pro`.`tb_book` <span class="hljs-keyword">where</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="4-select-type列"><a href="#4-select-type列" class="headerlink" title="4.select_type列"></a>4.select_type列</h2><p>关闭 MySQL 对衍生表的合并优化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;derived_merge=off&#x27;</span>; <br></code></pre></td></tr></table></figure><p>执行了这样的计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> tb_author <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>) der;<br></code></pre></td></tr></table></figure><div align=center>    <img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210518093837712.png" class="image-20210518093837712.png.png"></div><ul><li>derived：</li></ul><p>第一条执行的sql是from后面的子查询，该子查询只要在from后面，就会生成一张衍生表，因此他的查询类型：derived</p><ul><li>subquery：</li></ul><p>在select之后 from之前的子查询</p><ul><li>primary：</li></ul><p>最外部的select</p><ul><li>simple：</li></ul><p>不包含子查询的简单的查询</p><ul><li>union：</li></ul><p>使用union进行的联合查询的类型</p><h2 id="5-table列"><a href="#5-table列" class="headerlink" title="5.table列"></a>5.table列</h2><p>当前查询正在查哪张表</p><h2 id="6-type列"><a href="#6-type列" class="headerlink" title="6.type列"></a>6.type列</h2><p>type列可以直观的判断出当前的sql语句的性能。type里的取值和性能的优劣顺序如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">null</span> <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">system</span> <span class="hljs-operator">&gt;</span> const <span class="hljs-operator">&gt;</span> eq_ref <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">ref</span> <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">range</span> <span class="hljs-operator">&gt;</span> index <span class="hljs-operator">&gt;</span> <span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><p>对于SQL优化来说，要尽量保证type列的值是属于range及以上级别。</p><ul><li>null</li></ul><p>性能最好的，一般在使用了聚合函数操作索引列，结果直接从索引树获取即可，因此是性能最好。</p><ul><li>system</li></ul><p>很少见。直接和一条记录进行匹配。</p><ul><li>const</li></ul><p>使用主键索引或唯一索引和常量进行比较，这种性能非常好</p><ul><li>eq_ref</li></ul><p>在进行多表连接查询时。如果查询条件是使用了主键进行比较，那么当前查询类型是eq_ref</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book_author <span class="hljs-keyword">left</span> <span class="hljs-keyword">JOIN</span> tb_book <span class="hljs-keyword">on</span> tb_book_author.book_id <span class="hljs-operator">=</span> tb_book.id<br></code></pre></td></tr></table></figure><ul><li><p>ref</p><ul><li>简单查询：EXPLAIN select * from tb_book where name&#x3D;’book1’</li></ul><p>​      如果查询条件是普通列索引，那么类型ref</p><ul><li>复杂查询：EXPLAIN select book_id from tb_book left join tb_book_author on tb_book.id &#x3D; tb_book_author.book_id</li></ul><p>​     如果查询条件是普通列索引，那么类型ref</p></li><li><p>range:</p></li></ul><p> 使用索引进行范围查找</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>index</li></ul><p>查询没有进行条件判断。但是所有的数据都可以直接从索引树上获取(book表中的所有列都有索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book<br></code></pre></td></tr></table></figure><ul><li>all</li></ul><p>没有走索引，进行了全表扫描</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_author<br></code></pre></td></tr></table></figure><h2 id="7-id列"><a href="#7-id列" class="headerlink" title="7.id列"></a>7.id列</h2><p>在多个select中，id越大越先执行，如果id相同。上面的先执行。</p><h2 id="8-possible-keys列"><a href="#8-possible-keys列" class="headerlink" title="8.possible keys列"></a>8.possible keys列</h2><p>这一次的查询可能会用到的索引。也就是说mysql内部优化器会进行判断，如果这一次查询走索引的性能比全表扫描的性能要查，那么内部优化器就让此次查询进行全表扫描——这样的判断依据我们可以通过trace工具来查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;custome%&#x27;</span><br></code></pre></td></tr></table></figure><p>这条sql走索引查询的行数是500多万，那么总的数据行数也就500多万，因此直接进行全表扫描性能更快</p><div align=center>    <img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210518103742876.png" class="" title="image-20210518103742876"></div><h2 id="9-key列"><a href="#9-key列" class="headerlink" title="9.key列"></a>9.key列</h2><p>实际该sql语句使用的索引</p><h2 id="10-rows列"><a href="#10-rows列" class="headerlink" title="10.rows列"></a>10.rows列</h2><p>该sql语句可能要查询的数据条数</p><h2 id="11-key-len列"><a href="#11-key-len列" class="headerlink" title="11.key_len列"></a>11.key_len列</h2><p>键的长度，通过这一列可以让我们知道当前命中了联合索引中的哪几列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;customer10011&#x27;</span> # <span class="hljs-number">74</span><br>EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;customer10011&#x27;</span> <span class="hljs-keyword">and</span> age<span class="hljs-operator">=</span><span class="hljs-number">30</span> # <span class="hljs-number">74</span> <span class="hljs-number">4</span> <span class="hljs-operator">=</span> <span class="hljs-number">78</span><br>EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;customer10011&#x27;</span> <span class="hljs-keyword">and</span> age<span class="hljs-operator">=</span><span class="hljs-number">30</span> <span class="hljs-keyword">and</span> position<span class="hljs-operator">=</span><span class="hljs-string">&#x27;dev&#x27;</span> # <span class="hljs-number">74</span> <span class="hljs-number">4</span> <span class="hljs-number">62</span> <span class="hljs-operator">=</span> <span class="hljs-number">140</span><br>EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;customer10011&#x27;</span> <span class="hljs-keyword">and</span> position<span class="hljs-operator">=</span><span class="hljs-string">&#x27;dev&#x27;</span> # <span class="hljs-number">74</span><br></code></pre></td></tr></table></figure><p>name长度是74，也就是当看到key-len是74，表示使用了联合索引中的name列</p><div align=center>    <img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210518104705482.png" class="" title="image-20210518104705482"></div><p>计算规则：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 字符串<br><span class="hljs-bullet">1.</span> char(n): n字节长度<br><span class="hljs-bullet">2.</span> varchar(n): 2字节存储字符串长度,如果是utf-8,则长度3n + 2<br><br><span class="hljs-bullet">-</span> 数值类型<br><span class="hljs-bullet">1.</span> tinyint: 1字节<br><span class="hljs-bullet">2.</span> smallint: 2字节<br><span class="hljs-bullet">3.</span> int: 4字节<br><span class="hljs-bullet">4.</span> bigint: 8字节<br><br><span class="hljs-bullet">-</span> 时间类型<br><span class="hljs-bullet">1.</span> date: 3字节<br><span class="hljs-bullet">2.</span> timestamp: 4字节<br><span class="hljs-bullet">3.</span> datetime: 8字节<br><br>如果字段允许为NULL,需要1字节记录是否为NULL<br>索引最大长度是768字节,当字符串过长时, mysql会做一个类似左前缀索引的处理,将前半部分的字符提取出来做索引<br></code></pre></td></tr></table></figure><h2 id="12-extra列"><a href="#12-extra列" class="headerlink" title="12.extra列"></a>12.extra列</h2><p>extra列提供了额外的信息，是能够帮助我们判断当前sql的是否使用了覆盖索引、文件排序、使用了索引进行查询条件等等的信息。</p><ul><li><p>Using index:使用了覆盖索引</p><p>所谓的覆盖索引，指的是当前查询的所有数据字段都是索引列，这就意味着可以直接从索引列中获取数据，而不需要进行查表。</p><p>使用覆盖索引进行性能优化这种手段是之后sql优化经常要用到的。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> book_id,author_id <span class="hljs-keyword">from</span> tb_book_author <span class="hljs-keyword">where</span> book_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- 覆盖索引</span><br>EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book_author <span class="hljs-keyword">where</span> book_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-comment">-- 没有使用覆盖索引</span><br></code></pre></td></tr></table></figure><ul><li><p>using where</p><p>使用了普通索引列做查询条件</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_author <span class="hljs-keyword">where</span> name <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>using index condition</li></ul><p>查询结果没有使用覆盖索引，建议可以使用覆盖索引来优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_book_author <span class="hljs-keyword">where</span> book_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>Using temporary</li></ul><p>在非索引列上进行去重操作就需要使用一张临时表来实现，性能是非常差的。当前name列没有索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-keyword">DISTINCT</span> name <span class="hljs-keyword">from</span> tb_author<br></code></pre></td></tr></table></figure><ul><li>Using filesort</li></ul><p>使用文件排序： 会使用磁盘+内存的方式进行文件排序，会涉及到两个概念：单路排序、双路排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_author <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name<br></code></pre></td></tr></table></figure><ul><li>Select tables optimized away</li></ul><p>直接在索引列上进行聚合函数的操作，没有进行任何的表的操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-built_in">min</span>(id) <span class="hljs-keyword">from</span> tb_book<br></code></pre></td></tr></table></figure><h1 id="二、Trace工具"><a href="#二、Trace工具" class="headerlink" title="二、Trace工具"></a>二、Trace工具</h1><p>在执行计划中我们发现有的sql会走索引，有的sql即使明确使用了索引也不会走索引。这是因为mysql的内部优化器任务走索引的性能比不走索引全表扫描的性能要差，因此mysql内部优化器选择了使用全表扫描。依据来自于trace工具的结论。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=on&quot;, end_markers_in_json<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>; <span class="hljs-comment">-- 开启trace</span><br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position; <span class="hljs-comment">-- 执行查询</span><br> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.OPTIMIZER_TRACE; <span class="hljs-comment">-- 获得trace的分析结果</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;join_preparation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> -- 阶段<span class="hljs-number">1</span><span class="hljs-punctuation">:</span>进入到准备阶段<br>        <span class="hljs-attr">&quot;select#&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;expanded_query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/* select#1 */ select `employees`.`id` AS `id`,`employees`.`name` AS `name`,`employees`.`age` AS `age`,`employees`.`position` AS `position`,`employees`.`hire_time` AS `hire_time` from `employees` where (`employees`.`name` &gt; &#x27;a&#x27;) order by `employees`.`position`&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><br>      <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* join_preparation */</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;join_optimization&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> -- 阶段<span class="hljs-number">2</span><span class="hljs-punctuation">:</span> 进入到优化阶段<br>        <span class="hljs-attr">&quot;select#&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;condition_processing&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> -- 条件处理<br>              <span class="hljs-attr">&quot;condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;WHERE&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;original_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;transformation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;equality_propagation&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;resulting_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;transformation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;constant_propagation&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;resulting_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;transformation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;trivial_condition_removal&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;resulting_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>              <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><br>            <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* condition_processing */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;substitute_generated_columns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* substitute_generated_columns */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;table_dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> -- 表依赖详情<br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;row_may_be_null&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;map_bit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;depends_on_map_bits&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* depends_on_map_bits */</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* table_dependencies */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;ref_optimizer_key_uses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* ref_optimizer_key_uses */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;rows_estimation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;range_analysis&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;table_scan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;rows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5598397</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;cost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">576657</span><br>                  <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* table_scan */</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;potential_range_indexes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> -- 可能使用到的索引<br>                    <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;PRIMARY&quot;</span><span class="hljs-punctuation">,</span> -- 主键索引<br>                      <span class="hljs-attr">&quot;usable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;not_applicable&quot;</span><br>                    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;idx_name_age_position&quot;</span><span class="hljs-punctuation">,</span> -- 联合索引<br>                      <span class="hljs-attr">&quot;usable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;key_parts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                        <span class="hljs-string">&quot;name&quot;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-string">&quot;age&quot;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-string">&quot;position&quot;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-string">&quot;id&quot;</span><br>                      <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* key_parts */</span><br>                    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;idx_hire_time&quot;</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;usable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;not_applicable&quot;</span><br>                    <span class="hljs-punctuation">&#125;</span><br>                  <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* potential_range_indexes */</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;setup_range_conditions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                  <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* setup_range_conditions */</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;group_index_range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;chosen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;not_group_by_or_distinct&quot;</span><br>                  <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* group_index_range */</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;skip_scan_range&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;potential_skip_scan_indexes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                      <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;idx_name_age_position&quot;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;usable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;query_references_nonkey_column&quot;</span><br>                      <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* potential_skip_scan_indexes */</span><br>                  <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* skip_scan_range */</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;analyzing_range_alternatives&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> -- 分析各个索引使用的成本<br>                    <span class="hljs-attr">&quot;range_scan_alternatives&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                      <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;idx_name_age_position&quot;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;ranges&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                          <span class="hljs-string">&quot;a &lt; name&quot;</span><br>                        <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* ranges */</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;index_dives_for_eq_ranges&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;rowid_ordered&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;using_mrr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;index_only&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> -- 是否使用了覆盖索引<br>                        <span class="hljs-attr">&quot;rows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2799198</span><span class="hljs-punctuation">,</span> -- 要扫描的行数<br>                        <span class="hljs-attr">&quot;cost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2.08e6</span><span class="hljs-punctuation">,</span> -- 要花费的时间<br>                        <span class="hljs-attr">&quot;chosen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span> -- 是否选择使用这个索引<br>                        <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cost&quot;</span> -- 不选择的原因：开销比较大<br>                      <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* range_scan_alternatives */</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;analyzing_roworder_intersect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;usable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;too_few_roworder_scans&quot;</span><br>                    <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* analyzing_roworder_intersect */</span><br>                  <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* analyzing_range_alternatives */</span><br>                <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* range_analysis */</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* rows_estimation */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;considered_execution_plans&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;plan_prefix&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* plan_prefix */</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;best_access_path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> -- 最优访问路径<br>                  <span class="hljs-attr">&quot;considered_access_paths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> -- 最后选择的访问路径<br>                    <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;rows_to_scan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5598397</span><span class="hljs-punctuation">,</span> -- 全表扫描的行数<br>                      <span class="hljs-attr">&quot;access_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;scan&quot;</span><span class="hljs-punctuation">,</span> -- 全表扫描<br>                      <span class="hljs-attr">&quot;resulting_rows&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5.6e6</span><span class="hljs-punctuation">,</span> -- 结果的行数<br>                      <span class="hljs-attr">&quot;cost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">576655</span><span class="hljs-punctuation">,</span> -- 花费的时间<br>                      <span class="hljs-attr">&quot;chosen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> -- 选择这种方式<br>                      <span class="hljs-attr">&quot;use_tmp_table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                    <span class="hljs-punctuation">&#125;</span><br>                  <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* considered_access_paths */</span><br>                <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* best_access_path */</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;condition_filtering_pct&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;rows_for_plan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5.6e6</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;cost_for_plan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">576655</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;sort_cost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5.6e6</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;new_cost_for_plan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6.18e6</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;chosen&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* considered_execution_plans */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;attaching_conditions_to_tables&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;original_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;attached_conditions_computation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* attached_conditions_computation */</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;attached_conditions_summary&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;attached&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>              <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* attached_conditions_summary */</span><br>            <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* attaching_conditions_to_tables */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;optimizing_distinct_group_by_order_by&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;simplifying_order_by&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;original_clause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`.`position`&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;items&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                  <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;item&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`.`position`&quot;</span><br>                  <span class="hljs-punctuation">&#125;</span><br>                <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* items */</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;resulting_clause_is_simple&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;resulting_clause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`.`position`&quot;</span><br>              <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* simplifying_order_by */</span><br>            <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* optimizing_distinct_group_by_order_by */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;reconsidering_access_paths_for_index_ordering&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;clause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ORDER BY&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;index_order_summary&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;index_provides_order&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;order_direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;undefined&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;unknown&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;plan_changed&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>              <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* index_order_summary */</span><br>            <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* reconsidering_access_paths_for_index_ordering */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;finalizing_table_conditions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;original_table_condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;final_table_condition   &quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* finalizing_table_conditions */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;refine_plan&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`&quot;</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* refine_plan */</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;considering_tmp_tables&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;adding_sort_to_table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;employees&quot;</span><br>              <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* filesort */</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* considering_tmp_tables */</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><br>      <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* join_optimization */</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;join_execution&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;select#&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;steps&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;sorting_table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;employees&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;filesort_information&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>              <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;direction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;asc&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;expression&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;`employees`.`position`&quot;</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* filesort_information */</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;filesort_priority_queue_optimization&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;usable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;not applicable (no LIMIT)&quot;</span><br>            <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* filesort_priority_queue_optimization */</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;filesort_execution&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* filesort_execution */</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;filesort_summary&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;memory_available&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">262144</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;key_size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">40</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;row_size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">190</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;max_rows_per_buffer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1379</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;num_rows_estimate&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5598397</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;num_rows_found&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5913852</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;num_initial_chunks_spilled_to_disk&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1954</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;peak_memory_used&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">262144</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;sort_algorithm&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;std::stable_sort&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;sort_mode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&lt;fixed_sort_key, packed_additional_fields&gt;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* filesort_summary */</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><br>      <span class="hljs-punctuation">&#125;</span> <span class="hljs-comment">/* join_execution */</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span> <span class="hljs-comment">/* steps */</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="三、SQL优化实战"><a href="#三、SQL优化实战" class="headerlink" title="三、SQL优化实战"></a>三、SQL优化实战</h1><h2 id="1-order-by优化"><a href="#1-order-by优化" class="headerlink" title="1.order by优化"></a>1.order by优化</h2><p>在排序应用场景中，很容易出现文件排序的问题，文件排序会对性能造成影响，因此需要优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-keyword">using</span> filesort<br>Explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;customer&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position;<br># 没有使用文件排序 <br>Explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;customer&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age, position;<br># 不满足最左前缀法则，使用了文件排序<br>Explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;customer&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position, age;<br># 满足最左前缀法则，使用索引排序<br>Explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;customer&#x27;</span> <span class="hljs-keyword">and</span> age<span class="hljs-operator">=</span><span class="hljs-number">20</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position, age;<br><span class="hljs-keyword">show</span> WARNINGS;<br><span class="hljs-comment">/* select#1 */</span> <span class="hljs-keyword">select</span> `db_mysql_pro`.`employees`.`id` <span class="hljs-keyword">AS</span> `id`,`db_mysql_pro`.`employees`.`name` <span class="hljs-keyword">AS</span> `name`,`db_mysql_pro`.`employees`.`age` <span class="hljs-keyword">AS</span> `age`,`db_mysql_pro`.`employees`.`position` <span class="hljs-keyword">AS</span> `position`,`db_mysql_pro`.`employees`.`hire_time` <span class="hljs-keyword">AS</span> `hire_time` <span class="hljs-keyword">from</span> `db_mysql_pro`.`employees` <span class="hljs-keyword">where</span> ((`db_mysql_pro`.`employees`.`age` <span class="hljs-operator">=</span> <span class="hljs-number">20</span>) <span class="hljs-keyword">and</span> (`db_mysql_pro`.`employees`.`name` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;customer&#x27;</span>)) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> `db_mysql_pro`.`employees`.`position`<br># 排序方向不同，没有使用索引排序<br>Explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;customer&#x27;</span> <span class="hljs-keyword">and</span> age<span class="hljs-operator">=</span><span class="hljs-number">20</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age, position <span class="hljs-keyword">desc</span>;<br># 使用范围查询，使用了文件排序<br>Explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;customer&#x27;</span>,<span class="hljs-string">&#x27;aa&#x27;</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age, position;<br># 使用范围查询，使用了文件排序<br>Explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name;<br></code></pre></td></tr></table></figure><p>优化手段：</p><ul><li>如果排序的字段创建了联合索引，那么尽量在业务不冲突的情况下，遵循最左前缀法则来写排序语句。</li><li>如果文件排序没办法避免，那么尽量想办法使用覆盖索引。all-&gt;index</li></ul><h2 id="2-group-by优化"><a href="#2-group-by优化" class="headerlink" title="2.group by优化"></a>2.group by优化</h2><p>group by 的原理是先排序后分组，因此对于group by 的优化参考order by</p><h2 id="3-文件排序的原理"><a href="#3-文件排序的原理" class="headerlink" title="3.文件排序的原理"></a>3.文件排序的原理</h2><p>在执行文件排序的时候，会把查询的数据的大小与系统变量：max_length_for_sort_data的大小进行比较（默认是1024字节）,如果比系统变量小，那么执行单路排序，反之则执行双路排序</p><ul><li>单路排序</li></ul><p>​       把所有的数据扔到sort_buffer内存缓冲区中，进行排序，然后结束</p><ul><li><p>双路排序</p><p>取数据的排序字段和主键字段，在内存缓冲区中排序完成后，将主键字段做一次回表查询，获取完整数据。</p></li></ul><div align=center>    <img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210518144357614.png" class="" title="image-20210518144357614"></div><h2 id="4-分页优化"><a href="#4-分页优化" class="headerlink" title="4.分页优化"></a>4.分页优化</h2><p>对于这样的优化查询，mysql会把全部的10010数据拿到，并舍弃掉前面的10000条</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 一次行获取10010，再舍弃掉前10000条</span><br>Explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees limit <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p> 如果在主键连续的情况下，可以使用主键来做条件，但是这种情况是很少见的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">Explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;</span><span class="hljs-number">100000</span> limit <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>对于主键不连续情况下的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">Explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name limit <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span><br><span class="hljs-comment">-- 通过先进行覆盖索引的查找，然后在使用join做连接查询获取所有数据。这样比全表扫描要快</span><br>explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees a <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> name limit <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span>)  b <span class="hljs-keyword">on</span> a.id <span class="hljs-operator">=</span> b.id;<br></code></pre></td></tr></table></figure><h2 id="5-join优化"><a href="#5-join优化" class="headerlink" title="5.join优化"></a>5.join优化</h2><p>在join中会涉及到大表（数据量大）和小表（数据量小）的概念。MySQL内部优化器会根据关联字段是否创建了索引来使用不同的算法：</p><ul><li><p>Nlj(嵌套循环算法)：如果关联字段使用了索引，mysql会对小表做全表扫描，用小表的数据去和大表的数据去做索引字段的关联查询（type：ref）</p></li><li><p>bnlj（块嵌套循环算法）：如果关联字段没有使用索引，mysql会提供一个join buffer缓冲区，先把小表放到缓冲区中，然后全表扫描大表，把大表的数据和缓冲区中的小表数据在内存中进行匹配。</p></li></ul><p>结论：使用join查询时，一定要建立关联字段的索引，且两张表的关联字段在设计之初就要做到字段类型、长度是一致的，否则索引失效。</p><h2 id="6-in和exists优化"><a href="#6-in和exists优化" class="headerlink" title="6.in和exists优化"></a>6.in和exists优化</h2><p>在sql中如果A表是大表，B表是小表，那么使用in会更加合适。反之应该使用exists。</p><ul><li>in: B的数据量&lt;A的数据量</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B) <br># 相当于：<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B)&#123; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>B的数据量少，所以循环次数少。<br><br>   <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.id <span class="hljs-operator">=</span> B.id<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>exists:  B的数据量&gt;A的数据量 (10: id 1. 2. 3. 4)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id)  <span class="hljs-literal">true</span> <span class="hljs-operator">/</span> <span class="hljs-literal">false</span><br>等价于<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A)&#123;<br>   <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-count优化"><a href="#7-count优化" class="headerlink" title="7.count优化"></a>7.count优化</h2><p>对于count的优化应该是架构层面的优化，因为count的统计是在一个产品会经常出现，而且每个用户访问，所以对于访问频率过高的数据建议维护在缓存中。</p><div align=center>    <img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210518155019048.png" class="" title="image-20210518155019048"></div><h1 id="四、锁的定义和分类"><a href="#四、锁的定义和分类" class="headerlink" title="四、锁的定义和分类"></a>四、锁的定义和分类</h1><h2 id="1-锁的定义"><a href="#1-锁的定义" class="headerlink" title="1.锁的定义"></a>1.锁的定义</h2><p>锁是用来解决多个任务（线程、进程）在并发访问同一共享资源时带来的数据安全问题。虽然使用锁解决了数据安全问题，但是会带来性能的影响，频繁使用锁的程序的性能是必然很差的。</p><p>对于数据管理软件MySQL来说，必然会到任务的并发访问。那么MySQL是怎么样在数据安全和性能上做权衡的呢？——MVCC设计思想。</p><h2 id="2-锁的分类"><a href="#2-锁的分类" class="headerlink" title="2.锁的分类"></a>2.锁的分类</h2><h3 id="1）从性能上划分：乐观锁和悲观锁"><a href="#1）从性能上划分：乐观锁和悲观锁" class="headerlink" title="1）从性能上划分：乐观锁和悲观锁"></a>1）从性能上划分：乐观锁和悲观锁</h3><ul><li>悲观锁：悲观的认为当前的并发是非常严重的，所以在任何时候操作都是互斥。保证了线程的安全，但牺牲了并发性。——总有刁民要害朕。</li><li>乐观锁：乐观的认为当前的并发并不严重，因此对于读的情况，大家都可以进行，但是对于写的情况，再进行上锁。以CAS自旋锁，在某种情况下性能是ok的，但是频繁自旋会消耗很大的资源。——天网恢恢疏而不漏</li></ul><h3 id="2）从数据的操作细粒度上划分：表锁和行锁"><a href="#2）从数据的操作细粒度上划分：表锁和行锁" class="headerlink" title="2）从数据的操作细粒度上划分：表锁和行锁"></a>2）从数据的操作细粒度上划分：表锁和行锁</h3><ul><li>表锁：对整张表上锁</li><li>行锁：对表中的某一行上锁。</li></ul><h3 id="3）从数据库的操作类型上划分：读锁和写锁"><a href="#3）从数据库的操作类型上划分：读锁和写锁" class="headerlink" title="3）从数据库的操作类型上划分：读锁和写锁"></a>3）从数据库的操作类型上划分：读锁和写锁</h3><p>这两种锁都是属于悲观锁</p><ul><li>读锁（共享锁）：对于同一行数据进行”读“来说，是可以同时进行但是写不行。</li><li>写锁（拍他锁）：在上了写锁之后，及释放写锁之前，在整个过程中是不能进行任何的其他并发操作（其他任务的读和写是都不能进行的）。</li></ul><h2 id="3-表锁"><a href="#3-表锁" class="headerlink" title="3.表锁"></a>3.表锁</h2><p>对整张表进行上锁。MyISAM存储引擎是天然支持表锁的，也就是说在MyISAM的存储引擎的表中如果出现并发的情况，将会出现表锁的效果。MyISAM不支持事务。InnoDB支持事务</p><p>在InnoDB中上一下表锁:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 对一张表上读锁<span class="hljs-operator">/</span>写锁格式：<br>lock <span class="hljs-keyword">table</span> 表名 read<span class="hljs-operator">/</span>write;<br># 例子<br>lock <span class="hljs-keyword">table</span> tb_book read;<br># 查看当前会话对所有表的上锁情况<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">open</span> tables;<br># 释放当前会话的所有锁<br>unlock tables;<br></code></pre></td></tr></table></figure><p>读锁： 其他任务可以进行读，但是不能进行写</p><p>写锁：其他任务不能进行读和写。</p><h2 id="4-行锁"><a href="#4-行锁" class="headerlink" title="4.行锁"></a>4.行锁</h2><p>MyISAM只支持表锁，但不支持行锁，InnoDB可以支持行锁。</p><p>在并发事务里，每个事务的增删改的操作相当于是上了行锁。</p><p>上行锁的方式：</p><ul><li>update tb_book set name&#x3D;’qfjava2101’ where id&#x3D;8;  对id是8的这行数据上了行锁。</li><li>select * from tb_book where id&#x3D;5 for update; 对id是5的这行数据上了行锁。</li></ul><h1 id="五、MVCC设计思想"><a href="#五、MVCC设计思想" class="headerlink" title="五、MVCC设计思想"></a>五、MVCC设计思想</h1><p>MySQL为了权衡数据安全和性能，使用了MVCC多版本并发控制的设计。</p><h2 id="1-事务的特性"><a href="#1-事务的特性" class="headerlink" title="1.事务的特性"></a>1.事务的特性</h2><ul><li>原子性：一个事务是一个最小的操作单位（原子），多条sql语句在一个事务中要么同时成功，要么同时失败。</li><li>一致性：事务提交之前和回滚之后的数据是一致的。</li><li>持久性：事务一旦提交，对数据的影响是持久的。</li><li>隔离性：多个事务在并发访问下，提供了一套隔离机制，不同的隔离级别会有不同的并发效果。</li></ul><h2 id="2-事务的隔离级别"><a href="#2-事务的隔离级别" class="headerlink" title="2.事务的隔离级别"></a>2.事务的隔离级别</h2><ul><li>read uncommitted（读未提交）： 在一个事务中读取到另一个事务还没有提交的数据——脏读。</li><li>Read committed（读已提交）: 已经解决了脏读问题，在一个事务中只会读取另一个事务已提交的数据，这种情况会出现不可重复读的问题。就是：在事务中重复读数据，数据的内容是不一样的。</li><li>repeatable read（可重复读）：在一个事务中每次读取的数据都是一致的，不会出现脏读和不可重复读的问题。会出现虚读（幻读）的问题。</li></ul><p>什么是幻读：</p><div align=center>    <img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210519100046820.png" class="" title="image-20210519100046820"></div><p>解决方案：</p><p>通过上行锁来解决虚读问题：</p><img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210519100825916.png" class="" title="image-20210519100825916"><ul><li>Serializable:串行化的隔离界别直接不允许事务的并发发生，不存在任何的并发性。相当于锁表，性能非常差，一般都不考虑</li></ul><p>脏读、不可重复读、虚读（幻读）</p><h2 id="3-MVCC思想解读"><a href="#3-MVCC思想解读" class="headerlink" title="3.MVCC思想解读"></a>3.MVCC思想解读</h2><p>MySQL在读和写的操作中，对读的性能做了并发性的保障，让所有的读都是快照读，对于写的时候，进行版本控制，如果真实数据的版本比快照版本要新，那么写之前就要进行版本（快照）更新，这样就可以既能够提高读的并发性，又能够保证写的数据安全。</p><div align=center>    <img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210519095148255.png" class="" title="image-20210519095148255"></div><h1 id="六、死锁和间隙锁"><a href="#六、死锁和间隙锁" class="headerlink" title="六、死锁和间隙锁"></a>六、死锁和间隙锁</h1><h2 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1.死锁"></a>1.死锁</h2><p>所谓的死锁，就是开启的锁没有办法关闭，导致资源的访问因为无法获得锁而处于阻塞状态。</p><p>演示：事务A和事物B相互持有对方需要的锁而不释放，造成死锁的情况。</p><div align=center>    <img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210519104203183.png" class="" title="image-20210519104203183"></div><h2 id="2-间隙锁"><a href="#2-间隙锁" class="headerlink" title="2.间隙锁"></a>2.间隙锁</h2><p>行锁只能对某一行上锁，如果相对某一个范围上锁，就可以使用间隙锁。间隙锁给的条件where id&gt;13 and id&lt;19，会对13 和19 所处的间隙进行上锁。</p><div align=center>    <img src="/2021/01/13/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%BC%98%E5%8C%96/image-20210519105034758.png" class="" title="image-20210519105034758"></div>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>关系型数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>关系型数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程管理</title>
    <link href="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、进程的组成、组织、特征"><a href="#一、进程的组成、组织、特征" class="headerlink" title="一、进程的组成、组织、特征"></a>一、进程的组成、组织、特征</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/1.png" class=""></div><h2 id="2-组成"><a href="#2-组成" class="headerlink" title="2.组成"></a>2.组成</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/2.png" class=""></div><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/3.png" class=""></div><h2 id="3-组织"><a href="#3-组织" class="headerlink" title="3.组织"></a>3.组织</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/4.png" class=""></div><h2 id="4-特征"><a href="#4-特征" class="headerlink" title="4.特征"></a>4.特征</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/5.png" class=""></div><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/6.png" class=""></div><h1 id="二、进程的状态与转化"><a href="#二、进程的状态与转化" class="headerlink" title="二、进程的状态与转化"></a>二、进程的状态与转化</h1><h2 id="1-状态"><a href="#1-状态" class="headerlink" title="1.状态"></a>1.状态</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/7.png" class=""></div><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/8.png" class=""></div><h2 id="2-转换"><a href="#2-转换" class="headerlink" title="2.转换"></a>2.转换</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/9.png" class=""></div><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/10.png" class=""></div><h1 id="三、进程控制"><a href="#三、进程控制" class="headerlink" title="三、进程控制"></a>三、进程控制</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/11.png" class=""></div><p>简而言之，就是上图中的绿色箭头部分</p><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/12.png" class=""></div><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/13.png" class=""></div><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/14.png" class=""></div><h2 id="3-总结-1"><a href="#3-总结-1" class="headerlink" title="3.总结"></a>3.总结</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/15.png" class=""></div><h1 id="四、进程通信"><a href="#四、进程通信" class="headerlink" title="四、进程通信"></a>四、进程通信</h1><h2 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念"></a>1.概念</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/16.png" class=""></div><h2 id="2-方式一：共享存储"><a href="#2-方式一：共享存储" class="headerlink" title="2.方式一：共享存储"></a>2.方式一：共享存储</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/17.png" class=""></div><h2 id="3-方式二：管道通信"><a href="#3-方式二：管道通信" class="headerlink" title="3.方式二：管道通信"></a>3.方式二：管道通信</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/18.png" class=""></div><h2 id="4-方式三：消息传递"><a href="#4-方式三：消息传递" class="headerlink" title="4.方式三：消息传递"></a>4.方式三：消息传递</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/19.png" class=""></div><h2 id="5-总结-1"><a href="#5-总结-1" class="headerlink" title="5.总结"></a>5.总结</h2><div align=center>    <img src="/2020/11/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/20.png" class=""></div>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2020/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    <url>/2020/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么数据结构"><a href="#什么数据结构" class="headerlink" title="什么数据结构"></a>什么数据结构</h2><p>B+树</p><h2 id="MySQL的索引失效有哪些场景？"><a href="#MySQL的索引失效有哪些场景？" class="headerlink" title="MySQL的索引失效有哪些场景？"></a>MySQL的索引失效有哪些场景？</h2><ol><li>不符合最左匹配原则</li><li>在索引上使用计算、函数、类型的转换</li><li>使用了不等于</li><li>使用了 is null 或 is not null</li><li>使用了 like</li><li>字符串不加单引号</li></ol><h2 id="InnoDB引擎为什么使用B-树？"><a href="#InnoDB引擎为什么使用B-树？" class="headerlink" title="InnoDB引擎为什么使用B+树？"></a>InnoDB引擎为什么使用B+树？</h2><ol><li><p><strong>B+树空间利用率更高，可减少I&#x2F;O次数</strong></p><p> 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I&#x2F;O消耗。而因为B+树的内部节点只是作为索引使用，而不像B-树那样每个节点都需要存储硬盘指针。</p><p> 也就是说：B+树中每个非叶节点没有指向某个关键字具体信息的指针，所以每一个节点可以存放更多的关键字数量，即一次性读入内存所需要查找的关键字也就越多，减少了I&#x2F;O操作。</p><p> e.g.假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内 部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中是盘片旋转的时间)。</p></li><li><p><strong>增删文件（节点）时，效率更高</strong></p><p> 因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率，基于范围查询更好。</p></li><li><p><strong>B+树的查询效率更加稳定</strong></p><p> 因为B+树的每次查询过程中，都需要遍历从根节点到叶子节点的某条路径。所有关键字的查询路径长度相同，导致每一次查询的效率相当。</p><p> B-树的每个节点都有data域</p></li></ol><h2 id="为什么不适用-B-树"><a href="#为什么不适用-B-树" class="headerlink" title="为什么不适用 B- 树"></a>为什么不适用 B- 树</h2><p>B-树的每个节点都有data域，增加了 I&#x2F;O 操作，而B+数除了叶子节点有数据其他没有</p><h2 id="Innodb-和-myisam-分别适用于哪些场景"><a href="#Innodb-和-myisam-分别适用于哪些场景" class="headerlink" title="Innodb 和 myisam 分别适用于哪些场景"></a>Innodb 和 myisam 分别适用于哪些场景</h2><p>innodb 是一种事务性的存储引擎，一般的业务其实都是对可靠性有要求的，所以基本上都是用 innodb</p><p>而 myisam 是一种 olap 存储引擎，适用于读多写少的场景，比如像年度总结这种，我们只用来读取的数据，我们就可以适用 myisam 作为存储引擎</p><h2 id="为什么-myisam-在只读的情况下比-innodb-快"><a href="#为什么-myisam-在只读的情况下比-innodb-快" class="headerlink" title="为什么 myisam 在只读的情况下比 innodb 快"></a>为什么 myisam 在只读的情况下比 innodb 快</h2><p>存储结构有区别，myisam 是非聚簇索引，它的索引存储的都是我们具体的记录行的地址，</p><p>而 innodb 是聚簇索引，它可能会出现回表查询，而且每次查询都需要去维护一个 mvcc 版本的情况，因此相对而言会比较慢</p><h2 id="有一亿条数据，走主键索引，-mysql-底层-IO-次数"><a href="#有一亿条数据，走主键索引，-mysql-底层-IO-次数" class="headerlink" title="有一亿条数据，走主键索引， mysql 底层 IO 次数"></a>有一亿条数据，走主键索引， mysql 底层 IO 次数</h2><p>传统来看，如果是一个二叉树存了1亿条数据，是需要花费以2为底100000000的对数，向上取也就是27，也就是说如果以二叉树存储的话，获取一个节点最小可以1一次到，最多要27次，考虑到IO操作是非常消耗性能的，所以MySQL使用了B+树</p><p>一般来说，IO扫描一次磁盘块的大小是 4KB，而非叶子节点通常占用 16Byte，所以一个磁盘块可以存256个叶子节点<br>也就是说，不会像二叉树一样只能从左右两个节点进行判断，而是会通过 256 个节点判断，并且B+树的数据是存在叶子节点上的，所以速度非常稳定，所以花费的时间是 256 为底 1000000000 的对数，向上取也就是 4</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="执行一条语句的整体流程"><a href="#执行一条语句的整体流程" class="headerlink" title="执行一条语句的整体流程"></a>执行一条语句的整体流程</h2><h3 id="宏观上"><a href="#宏观上" class="headerlink" title="宏观上"></a>宏观上</h3><ol><li>通过连接器和 MySQL 建立连接</li><li>通过分析器、优化器、执行器</li><li>返回执行结果</li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><strong>连接器</strong>：管理连接，权限认证</p><p><strong>分析器</strong>：词法分析，语法分析</p><p><strong>优化器</strong>：执行计划生成，索引选择</p><p><strong>执行器</strong>：操作引擎，返回结果</p><h3 id="微观上"><a href="#微观上" class="headerlink" title="微观上"></a>微观上</h3><ol><li>客户端通过连接器权限认证后</li><li>查询缓存，命中则直接返回</li><li>通过分析器进行词法和语法的分析</li><li>优化器会根据一些成本的计算，去决定具体走哪个索引，或者连表的顺序，最终生成执行计划</li><li>执行器通过执行计划去调用存储引擎层的 API 接口</li><li>存储引擎层，它是一个可插拔的设计，不同的存储引擎会去实现一套统一的 API 接口</li></ol><p>因此可以自由的去更换我们的存储引擎，上层是无感知的</p><h2 id="redolog、undolog、binlog"><a href="#redolog、undolog、binlog" class="headerlink" title="redolog、undolog、binlog"></a>redolog、undolog、binlog</h2><p>redoLog：属于物理日志，事务中修改的任何数据，将最新的数据备份存储的位置，被称为重做日志</p><p>undoLog：数据库事务开始之前，会将要修改的记录存放到undo日志里，当事务回滚时或数据库崩溃时，可以利用undo日志撤销未提交事务对数据库产生的影响</p><p>binLog：属于innodb，binlog是属于mysql server自带功能，帮助实现数据恢复达到主从数据一致性</p><h1 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h1><h2 id="MySQL的调优看过吗？有调优经验吗？"><a href="#MySQL的调优看过吗？有调优经验吗？" class="headerlink" title="MySQL的调优看过吗？有调优经验吗？"></a>MySQL的调优看过吗？有调优经验吗？</h2><p>确保命中索引，在复合索引的条件下符合最左匹配原则<br>分页优化：先通过覆盖索引查找，再使用join连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B) <br># 相当于：A <span class="hljs-operator">&gt;</span> B<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B) &#123; <span class="hljs-operator">/</span><span class="hljs-operator">/</span>B的数据量少，所以循环次数少。<br>   <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.id <span class="hljs-operator">=</span> B.id<br>&#125;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id)  <span class="hljs-literal">true</span> <span class="hljs-operator">/</span> <span class="hljs-literal">false</span><br># 等价于 B <span class="hljs-operator">&gt;</span> A<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A) &#123;<br>   <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何发现慢SQL"><a href="#如何发现慢SQL" class="headerlink" title="如何发现慢SQL"></a>如何发现慢SQL</h2><p>万能的 explain 语句</p><h2 id="解决脏数据、可重复读、幻读的方式"><a href="#解决脏数据、可重复读、幻读的方式" class="headerlink" title="解决脏数据、可重复读、幻读的方式"></a>解决脏数据、可重复读、幻读的方式</h2><ol><li><strong>Read uncommitted（读未提交）</strong>： 在一个事务中读取到另一个事务还没有提交的数据</li><li><strong>Read committed（读已提交）</strong>: 已经解决了脏读问题，在一个事务中只会读取另一个事务已提交的数据，这种情况会出现不可重复读的问题。就是：在事务中重复读数据，数据的内容是不一样的</li><li><strong>Repeatable read（可重复读）</strong>：在一个事务中每次读取的数据都是一致的，不会出现脏读和不可重复读的问题。会出现虚读（幻读）的问题</li></ol><h2 id="怎么避免回表查询"><a href="#怎么避免回表查询" class="headerlink" title="怎么避免回表查询"></a>怎么避免回表查询</h2><p>覆盖索引，也就是 select 的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="MySQL中都有哪些锁？"><a href="#MySQL中都有哪些锁？" class="headerlink" title="MySQL中都有哪些锁？"></a>MySQL中都有哪些锁？</h2><ul><li>行锁</li><li>表锁</li></ul><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="基本语句，如何增加列？"><a href="#基本语句，如何增加列？" class="headerlink" title="基本语句，如何增加列？"></a>基本语句，如何增加列？</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ALTERTABLE table_name <span class="hljs-keyword">ADD</span> column_name datatype<br></code></pre></td></tr></table></figure><h2 id="查询语句的执行顺序"><a href="#查询语句的执行顺序" class="headerlink" title="查询语句的执行顺序"></a>查询语句的执行顺序</h2><ol><li>FROM table1 left join table2 on 将table1和table2中的数据产生笛卡尔积，生成Temp1</li><li>JOIN table2 所以先是确定表，再确定关联条件</li><li>ON table1.column &#x3D; table2.columu 确定表的绑定条件 由Temp1产生中间表Temp2</li><li>WHERE 对中间表Temp2产生的结果进行过滤 产生中间表Temp3</li><li>GROUP BY 对中间表Temp3进行分组，产生中间表Temp4</li><li>HAVING 对分组后的记录进行聚合 产生中间表Temp5</li><li>SELECT 对中间表Temp5进行列筛选，产生中间表 Temp6</li><li>DISTINCT 对中间表 Temp6进行去重，产生中间表 Temp7</li><li>ORDER BY 对Temp7中的数据进行排序，产生中间表Temp8</li><li>LIMIT 对中间表Temp8进行分页，产生中间表Temp9</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>关系型数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>关系型数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC</title>
    <link href="/2020/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC/"/>
    <url>/2020/11/06/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/JUC/</url>
    
    <content type="html"><![CDATA[<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="synchronized的锁优化有哪些、讲一下锁状态和锁升级"><a href="#synchronized的锁优化有哪些、讲一下锁状态和锁升级" class="headerlink" title="synchronized的锁优化有哪些、讲一下锁状态和锁升级"></a>synchronized的锁优化有哪些、讲一下锁状态和锁升级</h2><ol><li><p>优化 Monitor 这类的重量级锁 （轻量级锁）<br>每个线程中的栈帧都会包含一个锁记录对象（Lock Record），<br>内部可以通过 CAS 的方式存储锁定对象的 Mark Word（从而不再一开始就使用 Monitor）</p></li><li><p>自旋优化<br>当升级到重量级锁竞争时，如果发生竞争失败不会立即进入到 EntryList 进行阻塞，<br>而是会重试一会儿再阻塞</p></li><li><p>优化轻量级锁重入（偏向锁）轻量级锁在没有竞争时，每次重入操作仍需要 CAS，为了避免性能降低，所以引入了偏向锁优化轻量级锁重入，在第一次 CAS 时会将线程的 ID 写入对象的 Mark Word 中,此后线程发现锁定对象中的 Mark Word 存在自己的线程 ID，则不会再次进行 CAS，因为这个对象就归这个线程所有</p></li></ol><hr><h2 id="voliate关键字"><a href="#voliate关键字" class="headerlink" title="voliate关键字"></a>voliate关键字</h2><p>原理：</p><p>内存屏障，Memory Barrier（Memory Fence）</p><p>对 volatile 变量的写指令后会加入写屏障（屏障之前，对贡献变量的修改都是会同步到主存中）</p><p>对 volatile 变量的读指令前会加入读屏障（屏障之后，对共享变量的读取都是主存中的新数据）</p><p>作用：</p><ol><li>确保可见性</li><li>确保有序性</li></ol><p>保持内存可见性。所有线程都能看到共享内存的最新状态。每次读取前必须先从主内存刷新最新的值。每次写入后必须立即同步回主内存当中。</p><p>禁止指令重排。提供内存屏障的方式来防止指令被重排，编译器在生成字节码文件时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><h1 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h1><h2 id="什么情况下用-ReentrantLock-而不用-synchronized"><a href="#什么情况下用-ReentrantLock-而不用-synchronized" class="headerlink" title="什么情况下用 ReentrantLock 而不用 synchronized"></a>什么情况下用 ReentrantLock 而不用 synchronized</h2><ol><li>阻塞时可被中断</li><li>可以设置获取锁的超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量（condition）</li></ol><h2 id="Java的中断怎么实现，为什么-synchronized-不能中断，ReentrantLock-可以中断"><a href="#Java的中断怎么实现，为什么-synchronized-不能中断，ReentrantLock-可以中断" class="headerlink" title="Java的中断怎么实现，为什么 synchronized 不能中断，ReentrantLock 可以中断"></a>Java的中断怎么实现，为什么 synchronized 不能中断，ReentrantLock 可以中断</h2><ol><li>synchronized 是在JVM层面上实现的，在字节码中会有 monitorenter、monitorexit 介入，<br>会自动释放锁定（代码执行完成或者出现异常）</li><li>ReentrantLock 是实现 lock 接口和内部类继承 AQS 实现的，是通过代码实现的</li></ol><h2 id="ReentrantLock-怎么实现的（AQS）"><a href="#ReentrantLock-怎么实现的（AQS）" class="headerlink" title="ReentrantLock 怎么实现的（AQS）"></a>ReentrantLock 怎么实现的（AQS）</h2><p>通过实现 lock 接口以及结合继承了 AQS 的内部类 Sync 实现的</p><h2 id="AQS源码看过吗-能说一下么？"><a href="#AQS源码看过吗-能说一下么？" class="headerlink" title="AQS源码看过吗?能说一下么？"></a>AQS源码看过吗?能说一下么？</h2><ol><li><p>使用 CLH 队列，实现线程阻塞等待以及被唤醒时锁分配的机制</p></li><li><p>独享模式：</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">2.1 acquire 操作：<br>    2.1.1. 查看当前是否有线程占用锁，没有则修改 state 和 exclusiveOwnerThread <br>    为当前线程，否则加入 CLH 队列<br>    2.1.2. 加入 CLH 队列的第一个线程，需要初始化头节点，并设置头节点的 waitstatus 为 -1，<br>    next 节点指向当前线程，当前线程的 pre 指向头节点<br>    2.1.3. 当有新的线程加入 CLH 队列时，会重复将 pre 指向上一个节点，上一个节点<br>    的 next 节点指向当前线程并设置上一个节点的 waitstatus 为 -1，而自己的 waitstatus <br>    设置为 0。重复此操作。<br>    2.1.4. 当加入到 CLH 队列的线程获取到锁时，会修改 state 和持有锁的线程修改为当前<br>    线程，并且将 head 移至到当前节点，pre 节点也相应会断掉，之前的 head 节点会被 GC 回收<br>2.2 release 操作：<br>    2.2.1. 检查当前线程是否和 exclusiveOwnerThread 是同一个线程<br>    2.2.2. 修改锁的状态 status ，具体什么是有锁，什么是无锁，由 AQS 的子类定义<br>    2.2.3. 唤醒队列中头节点的下一个节点的线程<br>        2.2.3.1. 将自己的 waitStatus 设为 0<br>        2.2.3.2. 唤醒线程    <br></code></pre></td></tr></table></figure></li><li><p>共享模式：</p> <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">3.1 acquire 操作：<br>    3.1.1. 检查当前的 state，是否去持有锁。根据不同的 AQS 子类实现，来允许是否<br>    可以多个线程持有锁比如 CountDownLatch 类不允许，而 ReentrantReadWriteLock 类是允许的<br>    持有锁时只会去修改 state，而不会去修改 exclusiveOwnerThread<br>    3.1.2. 其他情况与独享模式类似<br><br>3.2 release 操作：<br>    3.2.1. 修改 state 字段<br>    3.2.2. 唤醒队列中头节点的下一个节点，如果被唤醒的节点的下一个节点也是 SHARED 模式，<br>    则一同唤醒<br></code></pre></td></tr></table></figure></li><li><p>条件队列</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">4.1 await 操作<br>     4.1.1. 创建条件节点，如果是作为第一个节点加入，则需要初始化队列，<br>     即初始化一个 head 节点，再把自己加入进去，作为 head 节点的 nextWaiter；<br>     否则直接加入，并使上一个节点的 nextWaiter 指向自己<br>     4.1.2. 释放当前线程占用的锁，执行 AQS 的 release 操作<br>     4.1.3. 挂起当前线程<br>     4.1.4. 被唤醒以后，执行 AQS 的 acquire 操作<br> 4.2 signal 操作：<br>     4.2.1. 将队列中的 firstWaiter 节点转移到同步队列中<br>     4.2.2. 把刚刚加入到同步队列中的节点的前驱的 waitStatus 设置为 -1 <br></code></pre></td></tr></table></figure></li></ol><h2 id="ThreadLocal，底层如何实现"><a href="#ThreadLocal，底层如何实现" class="headerlink" title="ThreadLocal，底层如何实现"></a>ThreadLocal，底层如何实现</h2><p>每个线程内都有一个ThreadLocalMap类型的成员变量，用来存储资源对象</p><p>ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，<br>那么但凡有一个线程对这个变量进行 set 操作时，这个线程中的 threadLocals 属性就会被创建赋值</p><p>所以当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;            <br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<span class="hljs-comment">// 拿到当前线程</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);   <span class="hljs-comment">// 拿到当前线程的 threadLocals 属性</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;                <br>        map.set(<span class="hljs-built_in">this</span>, value);         <span class="hljs-comment">// 不为空进行覆盖</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;                          <br>        createMap(t, value);          <span class="hljs-comment">// 为空则创建赋值</span><br>    &#125;                                 <br>&#125;                                     <br></code></pre></td></tr></table></figure><h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><h2 id="Java并发包下的原子工具类，能说一下么？源码看过吗？"><a href="#Java并发包下的原子工具类，能说一下么？源码看过吗？" class="headerlink" title="Java并发包下的原子工具类，能说一下么？源码看过吗？"></a>Java并发包下的原子工具类，能说一下么？源码看过吗？</h2><p>AtomicBoolean</p><p>AtomicInteger</p><p>AtomicLong</p><p>AtomicReference</p><p>AtomicIntegerArray</p><p>AtomicLongArray</p><p>AtomicReferenceArray</p><p>都是以CAS方式确保原子性，但是可能会触发ABA问题</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="为什么使用CAS就能保证并发"><a href="#为什么使用CAS就能保证并发" class="headerlink" title="为什么使用CAS就能保证并发?"></a>为什么使用CAS就能保证并发?</h2><p>无需阻塞等待，立马执行，立马返回成功或失败</p><h2 id="ABA问题及解决办法"><a href="#ABA问题及解决办法" class="headerlink" title="ABA问题及解决办法"></a>ABA问题及解决办法</h2><ol><li>AtomicStampedReference 需要我们传入整型变量作为版本号，来判定是否被更改过<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，就使用：</li><li>AtomicMarkableReference 需要我们传入布尔变量作为标记，来判断是否被更改过</li></ol><h2 id="IO密集和CPU密集两种情况下，线程池里的线程数应该怎么设置"><a href="#IO密集和CPU密集两种情况下，线程池里的线程数应该怎么设置" class="headerlink" title="IO密集和CPU密集两种情况下，线程池里的线程数应该怎么设置"></a>IO密集和CPU密集两种情况下，线程池里的线程数应该怎么设置</h2><p>IO密集型的话，是指系统大部分时间在跟I&#x2F;O交互，而这个时间线程不会占用CPU来处理，即在这个时间范围内，可以由其他线程来使用CPU，因而可以多配置一些线程。</p><p>CPU密集型的话，一般配置CPU处理器个数+1个线程， n + 1<br>所谓CPU密集型就是指系统大部分时间是在做程序正常的计算任务，例如数字运算、赋值、分配内存、内存拷贝、循环、查找、排序等，这些处理都需要CPU来完成。</p><h2 id="Java中创建多线程的方式有哪些"><a href="#Java中创建多线程的方式有哪些" class="headerlink" title="Java中创建多线程的方式有哪些"></a>Java中创建多线程的方式有哪些</h2><ol><li>继承Thread，重写run方法；方便传参，但不支持多继承</li><li>使用Runnable配合Thread；解耦强，灵活</li><li>FutureTask结合Thread；可以获得放回结果</li></ol><h2 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h2><p>悲观锁：拿到资源时，就对资源上锁，并在提交后，才释放锁资源，其他线程才能使用资源。</p><p>乐观锁：拿到资源时，上乐观锁，在提交之前，其他的锁也可以操作这个资源，当有冲突的时候，并发机制会保留前一个提交，打回后一个提交，让后一个线程重新获取资源后，再操作，然后提交。类似于 Git</p><p>吞吐量：乐观锁 &gt; 悲观锁</p><p>适用场景：读取频繁用乐观锁，写入频繁用悲观锁</p><p>特别地，如果吞吐量大，但是乐观锁获取锁的所消耗的性能又高，这个时候就不推荐适用乐观锁了</p><h2 id="什么是死锁，怎么破坏死锁"><a href="#什么是死锁，怎么破坏死锁" class="headerlink" title="什么是死锁，怎么破坏死锁"></a>什么是死锁，怎么破坏死锁</h2><p>死锁成立的四个条件：</p><p><strong>互斥</strong>：某种资源只允许一个进程访问</p><p><strong>占有且等待</strong>：一个进程本身占有了资源（一个或多个），同时还有资源未得到满足，正在等待其他进程释放该资源</p><p><strong>不可抢占</strong>：无法抢占别人占有的资源</p><p><strong>循环等待</strong>：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源</p><p>打破上述任何一个条件，便可让死锁消失</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池有哪些参数"><a href="#线程池有哪些参数" class="headerlink" title="线程池有哪些参数"></a>线程池有哪些参数</h2><ol><li>核心线程数</li><li>最大线程数</li><li>保持存活时间</li><li>时间单位</li><li>线程工厂</li><li>阻塞队列</li><li>拒绝策略</li></ol><h2 id="执行流程是什么？"><a href="#执行流程是什么？" class="headerlink" title="执行流程是什么？"></a>执行流程是什么？</h2><p>当一个任务传给线程池以后，可能有以下几种可能</p><ol><li>将任务分配给一个核心线程来执行</li><li>核心线程都在执行任务，将任务放到阻塞队列workQueue中等待被执行</li><li>阻塞队列满了，使用救急线程来执行任务；救急线程用完以后，超过生存时间（keepAliveTime）后会被释放</li><li>任务总数大于了 最大线程数（maximumPoolSize）与阻塞队列容量的最大值（workQueue.capacity），使用拒接策略</li></ol><h2 id="拒绝策略有哪些？"><a href="#拒绝策略有哪些？" class="headerlink" title="拒绝策略有哪些？"></a>拒绝策略有哪些？</h2><ol><li>AbortPolicy（堕胎政策-默认）：直接<strong>抛出RejectedExecutionException</strong>异常阻止系统正常运行</li><li>CallerRunsPolicy （调用者运行政策）:一种调节机制，该策略<strong>既不会抛弃任务，也不会抛出异常</strong>，而是将某些任务回退到调用者，从而降低新任务的流量</li><li>DiscardOldestPolicy（丢弃老的政策）：<strong>抛弃队列中等待最久的任务</strong>，然后把当前任务加入队列中尝试再次提交当前任务</li><li>DiscardPolicy（丢弃政策）：该策略默默地<strong>丢弃无法处理的任务，无予任何处理也不抛出异常</strong>。如果允许任务丢失，这是最好的一种策略</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
      <tag>多线程</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2020/10/18/Spring-Project/Spring/Spring/"/>
    <url>/2020/10/18/Spring-Project/Spring/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h1><h2 id="bean-的生命周期"><a href="#bean-的生命周期" class="headerlink" title="bean 的生命周期"></a>bean 的生命周期</h2><ol><li>创建前准备。Bean 在开始加载之前，会去上下文配置中查找并解析 Bean 相关的扩张，比如：<br>初始化的方法 init-method 和 destroy-method<br>以及 BeanFactoryPostProcessor 这一类 Bean 加载过程中前置后置的处理</li><li>创建实例。通过反射创建出 Bean 的实例对象，并且会扫描和解析 Bean 声明的属性。<br>但是此时的 Bean 是 Spring 内部的 Bean，不对外使用</li><li>依赖注入。检查 Bean 是否依赖于其他的 Bean，如果存在则需要的这些 Bean 进行依赖注入<br>常见的注解有：@Autowired、@Qualifier、@Resource<br>特别注意：@Resource的注解是属于J2EE的，按照名称进行装配<br>与此同时会去执行 BeanPostProcessors 接口实例的 postProcessBeforeInitialization()方法</li><li>初始化。组装成能够被使用的 Bean 对象。<br>如果Bean在XML文件中配置了init-method的方法、<br>实现了InitializingBean接口或者加上了@PostConstruct，会在这个阶段被调用<br>初始化结束后会去执行实现了<br>BeanPostProcessors接口的实例的postProcessAfterInitialization()方法</li><li>容器缓存。将 Bean 保存到对应的容器以及 Spring 的缓存中，这个阶段结束，<br>Bean就可以被开发者使用了</li><li>销毁实例。当应用上下文，也就是容器被关闭时，其中所有的 Bean 都会被销毁<br>如果Bean在XML文件中配置了destroy-method的方法、<br>实现了DisposableBean接口或者加上了@PreDestroy，会在这个阶段被调用</li></ol><h2 id="如何解决循环依赖"><a href="#如何解决循环依赖" class="headerlink" title="如何解决循环依赖"></a>如何解决循环依赖</h2><p>例如有两个 Bean A 和 B，A 依赖于 B，B 也依赖 A<br>初始化 bean 的时候会去一级缓存中查找，没有则去二级，<br>再没有则会通过存放 ObjectFactory 的三级缓存中得到一个半成品 bean，并放到二级缓存</p><p>而第一次加载 A，一级缓存和二级缓存肯定都是没有的，<br>所以会去三级缓存中拿到一个半成品 A，并放到二级缓存<br>此时 A 需要注入 B，同样的，第一次加载 B 肯定一二级缓存都没有，所以也会去三级缓存中</p><p>拿到一个半成品 B，并放到二级缓存</p><p>当 B 发现也需要注入 A 时，它此时就会在二级缓存中找到 A<br>这个时候将 A 注入到 B 中，同时删除二级缓存中的 B，添加到一级缓存中</p><p>当 B 注入完成后，A 又把一级缓存中的 B 注入到自己中来，并且删除二级缓存中的 A，添加到一级缓存</p><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="实现自动注入的方式"><a href="#实现自动注入的方式" class="headerlink" title="实现自动注入的方式"></a>实现自动注入的方式</h2><ol><li>@Autowired 一个实现类匹配</li><li>@Qualified 多个实现类指定</li><li>@Resource J2EE的，指定一个类</li></ol><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="Spring-AOP-原理"><a href="#Spring-AOP-原理" class="headerlink" title="Spring AOP 原理"></a>Spring AOP 原理</h2><p>AOP，Aspect Oriented Programming，面向切面编程<br>AOP分静态AOP和动态AOP。</p><p>静态 AOP 是指 AspectJ 实现的 AOP，将切面代码直接编译到 Java 类文件中</p><p>动态 AOP 是指将切面代码进行动态织入实现的 AOP</p><p>Spring AOP使用的是动态 AOP，主要采用了 JDK 提供的动态代理技术和 CGLIB 中的动态字节码增强技术</p><ol><li><p><strong>动态代理技术：</strong><br>实现原理是通过 target 和代理类实现同一个接口，代理类持有 target 对象，<br>来达到方法拦截的作用。<br>弊端：</p><p> i. 必须保证 target 类实现接口</p><p> ii. 如果想要对 target 方法进行拦截，那么这些方法都要在接口中声明，略微限制</p></li><li><p><strong>动态字节码增强技术：</strong><br>它既可以代理实现类，也可以代理接口。<br>底层是使用了 ASM （一个通用的 Java 字节码操作和分析框架）从而动态地生成被代理的子类<br>而它的原理是通过对字节码进行 CURD 操作，从而在 target 类的基础上生成 target 子类进而达到对方法的拦截</p></li></ol><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><h2 id="Spring-MVC-执行流程"><a href="#Spring-MVC-执行流程" class="headerlink" title="Spring MVC 执行流程"></a>Spring MVC 执行流程</h2><center><img src="/2020/10/18/Spring-Project/Spring/Spring/1.png" class=""></center><h1 id="Boot"><a href="#Boot" class="headerlink" title="Boot"></a>Boot</h1><h2 id="Spring-Boot-启动机制"><a href="#Spring-Boot-启动机制" class="headerlink" title="Spring Boot 启动机制"></a>Spring Boot 启动机制</h2><ol><li>@SpringBootConfiguration<br>它将启动类作为一个配置类加载到 Spring 容器中</li><li>@EnableAutoConfiguration &#x3D; @AutoConfigurationPackage + @Import<br>注册 spring 内部的 bean 以及插件式 bean，<br>例如 Nacos 里面的一些类就是在这一步通过 SPI注入进来</li><li>@ComponentScan<br>扫描程序员在启动类目录下的 bean</li></ol><h2 id="Spring-Boot-有哪些优点"><a href="#Spring-Boot-有哪些优点" class="headerlink" title="Spring Boot 有哪些优点"></a>Spring Boot 有哪些优点</h2><ol><li>配置变得简单，支持yml、properties进行配置</li><li>快速整合第三方框架</li><li>内嵌了servlet容器，比如Tomcat</li><li>注解化配置，避免了编写大量的样板代码，注释和XML配置</li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring Project</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2020/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2020/10/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="ArrayList、LinkedList和Vector的异同以及底层数据结构是"><a href="#ArrayList、LinkedList和Vector的异同以及底层数据结构是" class="headerlink" title="ArrayList、LinkedList和Vector的异同以及底层数据结构是"></a>ArrayList、LinkedList和Vector的异同以及底层数据结构是</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1、ArrayList  底层：是数组结构，查询快，增删慢，线程不安全，效率高。<br><br>2、LinkedList底层：是链表数据结构，查询慢，增删快，线程不安全，效率高。<br><br>3、Vector      底层：是数组结构，查询快，增删慢，线程安全，效率低。<br></code></pre></td></tr></table></figure><h3 id="ArrayList如何动态扩展"><a href="#ArrayList如何动态扩展" class="headerlink" title="ArrayList如何动态扩展"></a>ArrayList如何动态扩展</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">// 初始化：<br>1. ArrayList()会使用长度为 0 的数组<br>2. ArrayList(int initialCapacity)会使用指定容量的数组<br>3. public ArrayList(Collection&lt;? extends E&gt; c)会使用 c 的大小作为数组容量<br>    <br>// 添加：<br>1. add(Object o)首次扩容为 10，再次扩容为上次容量的1.5倍<br>2. addAll(Collection c) <br>    2.1 没有元素时，扩容为Math.max(10,实际元素个数)<br>    2.2 有元素时，扩容为Math.max(原容量1.5倍,实际元素个数)<br></code></pre></td></tr></table></figure><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="HashMap的底层数据结构"><a href="#HashMap的底层数据结构" class="headerlink" title="HashMap的底层数据结构"></a>HashMap的底层数据结构</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">JDK1.7 数组+链表<br><br>JDK 1.8 数组+（链表/红黑树）<br></code></pre></td></tr></table></figure><h3 id="为何要用红黑树"><a href="#为何要用红黑树" class="headerlink" title="为何要用红黑树"></a>为何要用红黑树</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">1. 数值较大时，使用红黑树可以优化查询性能<br>2. 可以避免DoS攻击，防止有人恶意使用多个hashcode一样的值注入攻击，避免链表超长性能下降<br></code></pre></td></tr></table></figure><h3 id="为何一上来不树化"><a href="#为何一上来不树化" class="headerlink" title="为何一上来不树化"></a>为何一上来不树化</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">数值较小时，链表的查询性能、内存占用较优于红黑树，所以不需要一上就树化<br>查找更新的时间复杂度是O(log&lt;sub&gt;2&lt;/sub&gt;n)<br>TreeNode占用空间也比普通Node要大<br>如非必要尽量使用链表<br></code></pre></td></tr></table></figure><h3 id="树化阈值为何是8"><a href="#树化阈值为何是8" class="headerlink" title="树化阈值为何是8"></a>树化阈值为何是8</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hash表内按泊松分布，在负载因子是0.75的情况下，长度超过8的链表出现概率是0.00000006，选择8是为了让树化几率足够小<br></code></pre></td></tr></table></figure><h3 id="何时会树化"><a href="#何时会树化" class="headerlink" title="何时会树化"></a>何时会树化</h3><blockquote><p>链表长度超过树化阈值8；数组容量&gt;&#x3D;64</p></blockquote><h3 id="何时会退化为链表"><a href="#何时会退化为链表" class="headerlink" title="何时会退化为链表"></a>何时会退化为链表</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">情况1：在扩容时如果树被拆分了，且树的元素个数&lt;=6则会退化成链表<br>情况2：remove树节点时，若移除节点之前root、root.left、root.right、root.left.left有一个为null时，也会退化成链表<br></code></pre></td></tr></table></figure><h3 id="索引如何计算"><a href="#索引如何计算" class="headerlink" title="索引如何计算"></a>索引如何计算</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">计算对象的hashCode()，再进行HashMap的hash()方法进行二次哈希，最后hash 求模% 或 &amp;(capacity - 1) 得到索引<br></code></pre></td></tr></table></figure><h3 id="为什么要二次哈希"><a href="#为什么要二次哈希" class="headerlink" title="为什么要二次哈希"></a>为什么要二次哈希</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">二次哈希是为了综合高位数据，让哈希分布更为均匀<br></code></pre></td></tr></table></figure><h3 id="数组容量为何是2的n次幂"><a href="#数组容量为何是2的n次幂" class="headerlink" title="数组容量为何是2的n次幂"></a>数组容量为何是2的n次幂</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. 计算索引时，<span class="hljs-number">2</span>的n次幂可以使用位与运算取代取模，效率更高<br><span class="hljs-attribute">2</span>. 扩容时可以根据hash &amp; oldCap == <span class="hljs-number">0</span> 来判断元素是否留在原来位置，否则 新位置 = 旧位置 + oldCap<br><span class="hljs-attribute">3</span>. 是为了配合索引计算、二次哈希的优化手段，例如HashTable的容量就不是<span class="hljs-number">2</span>的n次幂，并不能说那种设计更优，应该是设计者综合了各种因素，最终选择了使用<span class="hljs-number">2</span>的n次幂作为容量<br></code></pre></td></tr></table></figure><h3 id="HashTable与HashMap的区别"><a href="#HashTable与HashMap的区别" class="headerlink" title="HashTable与HashMap的区别"></a>HashTable与HashMap的区别</h3><table><thead><tr><th align="center">HashMap</th><th align="center">线程不安全</th><th align="center">允许有null的键和值</th><th align="center">效率高一点</th><th align="center">方法不是Synchronize的</th><th align="center">有containsValue和containsKey方法</th></tr></thead><tbody><tr><td align="center">HashTable</td><td align="center">线程安全</td><td align="center">不允许有null的键和值</td><td align="center">效率稍低</td><td align="center">方法是Synchronize的</td><td align="center">有contains方法方法</td></tr></tbody></table><h3 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. HashMap的容量是有上限的，必须小于 <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>，也就是<span class="hljs-number">2</span>的<span class="hljs-number">30</span>次幂 = <span class="hljs-number">1073741824</span><br><span class="hljs-attribute">2</span>. 空参数的构造函数：实例化的HashMap默认内部数组是null，即没有实例化。第一次调用put方法时，则会开始第一次初始化扩容，长度是<span class="hljs-number">16</span><br><span class="hljs-attribute">3</span>. 有参构造函数：用于指定容量。会根据指定的正整数找到不小于指定容量的<span class="hljs-number">2</span>的幂数，将这个数设置赋值给阈值（threshold）。第一次调用put方法时，会将阈值赋值给容量。<br><span class="hljs-attribute">4</span>. 如果不是第一次扩容，则容量变为原来的<span class="hljs-number">2</span>倍，阈值也变为原来的<span class="hljs-number">2</span>倍。（容量和阈值都变为原来的<span class="hljs-number">2</span>倍时，负载因子还是不变）<br></code></pre></td></tr></table></figure><h3 id="HashMap是不是线程安全的"><a href="#HashMap是不是线程安全的" class="headerlink" title="HashMap是不是线程安全的"></a>HashMap是不是线程安全的</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">不是，会发生数据错乱<br>并发情况下使用ConcurrentHashMap<br></code></pre></td></tr></table></figure><h3 id="HashMap的put元素的过程"><a href="#HashMap的put元素的过程" class="headerlink" title="HashMap的put元素的过程"></a>HashMap的put元素的过程</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. HashMap是懒惰创建数组的，首次使用才创建数组<br><span class="hljs-attribute">2</span>. 计算索引（桶下标）<br><span class="hljs-attribute">3</span>. 如果桶下标没有被占用，创建Node占位返回<br><span class="hljs-attribute">4</span>. 如果桶下标已经被占用<br><span class="hljs-attribute">4</span>.<span class="hljs-number">1</span> 如果节点是TreeNode走红黑树的添加或更新逻辑<br><span class="hljs-attribute">4</span>.<span class="hljs-number">2</span> 如果节点是Node，走链表的添加或更新逻辑<br><span class="hljs-attribute">4</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span> 如果添加时超过树化阈值且容量大于<span class="hljs-number">64</span>，走树化逻辑<br><span class="hljs-attribute">5</span>. 返回容量是否超过阈值，一旦超过就进行扩容<br><span class="hljs-attribute">5</span>.<span class="hljs-number">1</span> 如果进行扩容，要对旧元素重新计算索引<br></code></pre></td></tr></table></figure><h3 id="为什么加载因子是0-75"><a href="#为什么加载因子是0-75" class="headerlink" title="为什么加载因子是0.75"></a>为什么加载因子是0.75</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 在空间占用与查询时间之间取得较好的权衡<br><span class="hljs-bullet">2.</span> 大于这个值，空间节省了，但链表会比较长，影响性能<br><span class="hljs-bullet">3.</span> 小于这个字，冲突减少了，但扩容会比较频繁，空间占用多<br></code></pre></td></tr></table></figure><h3 id="Node的数据结构"><a href="#Node的数据结构" class="headerlink" title="Node的数据结构"></a>Node的数据结构</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 链表节点结构</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> Map.Entry&lt;K,V&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> hash;<br>        <span class="hljs-keyword">final</span> K key;<br>        V value;<br>        Node&lt;K,V&gt; <span class="hljs-keyword">next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="寻址算法"><a href="#寻址算法" class="headerlink" title="寻址算法"></a>寻址算法</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 将高16位和低16位进行了异或运算</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>)&#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashColde</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="红黑树的数据结构，左旋和右旋是怎样实现的"><a href="#红黑树的数据结构，左旋和右旋是怎样实现的" class="headerlink" title="红黑树的数据结构，左旋和右旋是怎样实现的"></a>红黑树的数据结构，左旋和右旋是怎样实现的</h2><ul><li>所有节点非红即黑</li><li>根节点是黑色</li><li>叶子节点是黑色</li><li>不能有连续的红色</li><li>任意节点到叶子节点路径中有相同数量的黑色节点</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">左旋：当前父结点是红色，叔叔是黑色的时候，且当前的结点是右子树。左旋以父节点作为左旋<br><br>右旋：当前父结点是红色，叔叔是黑色的时候，且当前的结点是左子树。右旋<br></code></pre></td></tr></table></figure><h2 id="什么是Huffman树"><a href="#什么是Huffman树" class="headerlink" title="什么是Huffman树"></a>什么是Huffman树</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">给定<span class="hljs-built_in">N</span>个权值作为<span class="hljs-built_in">N</span>个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。<br></code></pre></td></tr></table></figure><h2 id="Huffman树的用途"><a href="#Huffman树的用途" class="headerlink" title="Huffman树的用途"></a>Huffman树的用途</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">哈夫曼编码<br></code></pre></td></tr></table></figure><h2 id="Huffman树什么情况下压缩效率高"><a href="#Huffman树什么情况下压缩效率高" class="headerlink" title="Huffman树什么情况下压缩效率高"></a>Huffman树什么情况下压缩效率高</h2><h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">B</span>树也称为<span class="hljs-selector-tag">B</span>-树<br><br><span class="hljs-selector-tag">B</span>+树是<span class="hljs-selector-tag">B</span>-树的一种变体<br><br><span class="hljs-selector-tag">B</span>+树把数据存放在叶子节点上，并有序排列，这样做刚好适用于范围查询<br><span class="hljs-selector-tag">B</span>+树最终会呈现出一个矮胖地形式，<span class="hljs-selector-tag">B</span>-树则是高瘦<br></code></pre></td></tr></table></figure><h2 id="对TreeMap的理解"><a href="#对TreeMap的理解" class="headerlink" title="对TreeMap的理解"></a>对TreeMap的理解</h2><h2 id="TreeMap的底层数据结构"><a href="#TreeMap的底层数据结构" class="headerlink" title="TreeMap的底层数据结构"></a>TreeMap的底层数据结构</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">TreeMap</span>基于红黑树（<span class="hljs-built_in">Red</span><span class="hljs-operator">-</span><span class="hljs-built_in">Black</span> <span class="hljs-variable">tree</span>）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 <span class="hljs-variable">Comparator</span> 进行排序，具体取决于使用的构造方法。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统概述</title>
    <link href="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/1.png" class=""></div> <div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/2.png" class=""></div> <h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/3.png" class=""></div> <div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/4.png" class=""></div> <div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/5.png" class=""></div> <div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/6.png" class=""></div> <div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/7.png" class=""></div> <div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/8.png" class=""></div> <div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/9.png" class=""></div> <div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/10.png" class=""></div> <h1 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h1><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>就是<strong>处理器（CPU）</strong>能识别、执行的最基本命令</p><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/11.png" class=""></div> <h2 id="处理器状态"><a href="#处理器状态" class="headerlink" title="处理器状态"></a>处理器状态</h2><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/12.png" class=""></div> <h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/13.png" class=""></div> <h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/14.png" class=""></div> 操作系统中的哪些功能应该由内核程序实现呢？<h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/15.png" class=""></div> <h2 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h2><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/16.png" class=""></div><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/17.png" class=""></div><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/18.png" class=""></div><h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/19.png" class=""></div><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/20.png" class=""></div><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/21.png" class=""></div><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/22.png" class=""></div><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/23.png" class=""></div><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/24.png" class=""></div><h2 id="与库函数的区别"><a href="#与库函数的区别" class="headerlink" title="与库函数的区别"></a>与库函数的区别</h2><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/25.png" class=""></div><h2 id="调用细节"><a href="#调用细节" class="headerlink" title="调用细节"></a>调用细节</h2><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/26.png" class=""></div> <h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><div align=center>    <img src="/2020/10/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/27.png" class=""></div> ]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要参考<a href="https://leetcode.cn/u/liweiwei1419/">liweiwei1419</a>的<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/">题解</a>以及下方评论</p><p>关于快速排序的总结也是参考<a href="https://space.bilibili.com/236935093">liweiwei1419</a>的<a href="https://www.bilibili.com/video/BV1fS4y1a7zF/?spm_id_from=333.999.0.0&vd_source=6e718059dd9214836c56510c968c9987">《算法不好玩》专题六：快速排序</a></p></blockquote><p><strong>下面有一段无关标题的废话要说，不想看直接点击跳过</strong></p><h3 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1 摘要"></a>1 摘要</h3><p>前天写完<a href="https://huajframe.github.io/2020/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/">十个经典排序</a>的博客后就寻思找几个题试试手，结果找到了力扣的<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/">215. Kth Largest Element in an Array (Medium)</a>，结果证明自己还是太年轻，不过经过努力奋斗，对优先队列，堆排序，选择排序的有了更深一步的认识。</p><h4 id="1-1-优先队列是没啥好说的，主要使用到Java的PriorityQueue（小顶堆）-出队，入队已经封装好了、调整堆的过程已经省去，只要调用就行；贴一个题解"><a href="#1-1-优先队列是没啥好说的，主要使用到Java的PriorityQueue（小顶堆）-出队，入队已经封装好了、调整堆的过程已经省去，只要调用就行；贴一个题解" class="headerlink" title="1.1 优先队列是没啥好说的，主要使用到Java的PriorityQueue（小顶堆）,出队，入队已经封装好了、调整堆的过程已经省去，只要调用就行；贴一个题解:"></a>1.1 优先队列是没啥好说的，主要使用到Java的<code>PriorityQueue</code>（小顶堆）,出队，入队已经封装好了、调整堆的过程已经省去，只要调用就行；贴一个题解:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">// 小顶堆</span><br>    PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(); <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> val : nums) &#123;<br>        pq.add(val);<br>        <span class="hljs-comment">// 维护堆的大小为 K</span><br>        <span class="hljs-keyword">if</span> (pq.size() &gt; k)  <br>            pq.poll();<br>    &#125;<br>    <span class="hljs-keyword">return</span> pq.peek();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2再就是基于堆排序，不了解堆排序的可以参考堆排序-Heap-Sort-，主要是建堆、调整堆，也贴一个题解："><a href="#1-2再就是基于堆排序，不了解堆排序的可以参考堆排序-Heap-Sort-，主要是建堆、调整堆，也贴一个题解：" class="headerlink" title="1.2再就是基于堆排序，不了解堆排序的可以参考堆排序(Heap Sort)，主要是建堆、调整堆，也贴一个题解："></a>1.2再就是基于堆排序，不了解堆排序的可以参考<a href="https://huajframe.github.io/2020/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/#2-7-%E5%A0%86%E6%8E%92%E5%BA%8F-Heap-Sort">堆排序(Heap Sort)</a>，主要是建堆、调整堆，也贴一个题解：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">//创建大根堆</span><br>    buildMaxHeap(nums);<br>    <span class="hljs-comment">//开始排序，这里只需要排 k - 1次序，就可以保证堆顶的数第K大</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; k; i++)&#123;<br>        <span class="hljs-comment">//交换堆顶和堆尾</span><br>        swap(nums, <span class="hljs-number">0</span>, nums.length - i);<br>        <span class="hljs-comment">//调整堆，保持大根堆的状态</span><br>        adjustHeap(nums, <span class="hljs-number">0</span>, nums.length - i);<br>    &#125;<br>    <span class="hljs-comment">//返回堆顶元素</span><br>    <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> nums.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &gt;= <span class="hljs-number">0</span>; --i)&#123;<br>        adjustHeap(nums, i, nums.length);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> high)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> parent * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> parent * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">largest</span> <span class="hljs-operator">=</span> parent;<br>    <span class="hljs-comment">//找出左右孩子中的最大值，与根节点交换</span><br>    <span class="hljs-keyword">if</span>(right &lt; high &amp;&amp; nums[largest] &lt; nums[right])&#123;<br>        largest = right;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(left &lt; high &amp;&amp; nums[largest] &lt; nums[left])&#123;<br>        largest = left;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(largest != parent)&#123;<br>        swap(nums, parent, largest);<br>        <span class="hljs-comment">//如果左右孩子与根节点交换成功，以左右孩子为根节点的数就要进行调整</span><br>        adjustHeap(nums, largest, high);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> index1, <span class="hljs-type">int</span> index2)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[index1];<br>    nums[index1] = nums[index2];<br>    nums[index2] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-快速选择"><a href="#1-3-快速选择" class="headerlink" title="1.3 快速选择"></a>1.3 快速选择</h4><p>节省点篇幅，主要是讲快速排序而不是快速选择的[狗头]，看题解吧<br><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/">https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/partitionfen-er-zhi-zhi-you-xian-dui-lie-java-dai-/</a></p><h3 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2 快速排序"></a>2 快速排序</h3><p>以力扣<a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a>作为性能评判标准</p><h4 id="2-1-单方向遍历快排"><a href="#2-1-单方向遍历快排" class="headerlink" title="2.1 单方向遍历快排"></a>2.1 单方向遍历快排</h4><p>详情可见<a href="http://localhost:4000/2020/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/#2-6-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Quick-Sort">2.6 快速排序(Quick Sort)</a></p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>            <span class="hljs-comment">//划分</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivotIndex</span> <span class="hljs-operator">=</span> partition(nums, left, right);<br>            quickSort(nums, left, pivotIndex - <span class="hljs-number">1</span>);<br>            quickSort(nums, pivotIndex + <span class="hljs-number">1</span>, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[left];<br>        <span class="hljs-comment">//记录比基准值大的数的指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>; i &lt;= right; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; pivot)&#123;<br>                swap(nums, i, index);<br>                index++;<br>            &#125; <br>        &#125;<br>        swap(nums, left, --index);<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效率，很不幸，超时</p><center><img src="/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E5%8D%95%E5%90%91%E5%BF%AB%E6%8E%92.png" class=""></center><p>超时要向出改进方法，快速排序要求数组的顺序越随机越好</p><ul><li>问题：对于顺序数组或者逆序数组来说，递归树高度增加、递归树倾斜；</li><li>再提出解决方案：破坏顺序性，随机选择 pivot。</li></ul><p>快速排序对于有序的数组并没有那么友好</p><center><img src="/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E9%9A%8F%E6%9C%BA%E5%88%92%E5%88%86.jpg" class=""></center><p>避免这种最坏的情况出现，我们在切分 partition 之前，只需要在待排序的区间里，随机选择一个元素交换到数组的第 1 个位置就可以了，这样，最坏的情况出现的概率就极其低了。</p><p>针对特殊测试用例（顺序数组或者逆序数组）一定要随机化选择切分元素（<code>pivot</code>），否则在输入数组是有序数组或者是逆序数组的时候，快速排序会变得非常慢（等同于冒泡排序或者「选择排序」）。</p><p><strong>优化：随机选择标定点元素，降低递归树结构不平衡的情况</strong></p><p>由于快速排序在近乎有序的时候会非常差，此时递归树的深度会增加。此时快速排序的算法就退化为 &#96;O(N^2)。</p><p>解决办法：我们在每一次迭代开始之前，随机选取一个元素作为基准元素与第 1 个元素交换即可。</p><p>改进后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">RANDOM</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>            <span class="hljs-comment">//划分</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivotIndex</span> <span class="hljs-operator">=</span> partition(nums, left, right);<br>            quickSort(nums, left, pivotIndex - <span class="hljs-number">1</span>);<br>            quickSort(nums, pivotIndex + <span class="hljs-number">1</span>, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomIndex</span> <span class="hljs-operator">=</span> RANDOM.nextInt(right - left + <span class="hljs-number">1</span>) + left;<br>        swap(nums, left, randomIndex);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[left];<br>        <span class="hljs-comment">//记录比基准值大的数的指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>; i &lt;= right; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; pivot)&#123;<br>                swap(nums, i, index);<br>                index++;<br>            &#125; <br>        &#125;<br>        swap(nums, left, --index);<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>性能：</p><center><img src="/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E9%9A%8F%E6%9C%BA%E5%88%92%E5%88%86%E5%8D%95%E5%90%91%E5%BF%AB%E6%8E%92.png" class=""></center><h4 id="2-2-双路快排"><a href="#2-2-双路快排" class="headerlink" title="2.2 双路快排"></a>2.2 双路快排</h4><p>当数组中有很多值相同元素的时候，此时随机选择一个元素来与首位值来交换，这样很容易选到和首位相同的数，这样的交换是没有意义的</p><p>解决办法：</p><blockquote><p>双路快排：把和pivot相等的值<strong>平均</strong>分配到数组两侧</p><p>三路快排：把和pivot相等的值放在数组中间</p></blockquote><p>这里讲解双路快排</p><p>参考代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">RANDOM</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>            <span class="hljs-comment">//划分</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivotIndex</span> <span class="hljs-operator">=</span> partition(nums, left, right);<br>            quickSort(nums, left, pivotIndex - <span class="hljs-number">1</span>);<br>            quickSort(nums, pivotIndex + <span class="hljs-number">1</span>, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomIndex</span> <span class="hljs-operator">=</span> RANDOM.nextInt(right - left + <span class="hljs-number">1</span>) + left;<br>        swap(nums, left, randomIndex);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[left];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>, high = right;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">while</span>(low &lt;= high &amp;&amp; nums[low] &lt; pivot)&#123;<br>                ++low;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(low &lt;= high &amp;&amp; nums[high] &gt; pivot)&#123;<br>                --high;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(low &gt;= high)&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            swap(nums, low, high);<br>            ++low;<br>            --high;<br>        &#125;<br>        swap(nums, left, high);<br>        <span class="hljs-keyword">return</span> high;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>性能分析：快了不只一个档次</p><center><img src="/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E5%8F%8C%E8%B7%AF%E5%BF%AB%E6%8E%92%E6%80%A7%E8%83%BD.png" class=""></center><h4 id="2-3-三路快排"><a href="#2-3-三路快排" class="headerlink" title="2.3 三路快排"></a>2.3 三路快排</h4><p>三路快排就是将等于<code>pivot</code>的数字都放在数组中间，这样就只需要对大于和小于<code>pivot</code>值进行递归排序了，如果当划分值等于大量重复的值的时候，可以大大减少排序区间</p><p>weiwei哥的视频讲的更加详细，截了几张图，帮助自己加深印象</p><center><img src="/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5.png" class=""><br><br><img src="/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92%E5%8C%BA%E9%97%B4.png" class=""><br><br><img src="/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92%E5%8E%9F%E7%90%86.png" class=""></center><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">RANDOM</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">randomIndex</span> <span class="hljs-operator">=</span> RANDOM.nextInt(right - left + <span class="hljs-number">1</span>) + left;<br>            swap(nums, left, randomIndex);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> nums[left];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>, high = right;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> left + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span>(i &lt;= high)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &lt; pivot)&#123;<br>                    swap(nums, i, low);<br>                    ++i;<br>                    ++low;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[i] == pivot)&#123;<br>                    ++i;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    swap(nums, i, high);<br>                    --high;<br>                    <span class="hljs-comment">//此时交换的的数可能比pivot, 不需要i++</span><br>                &#125;  <br>            &#125;<br>            <span class="hljs-comment">//low此时刚好位于比第一个等于pivot的位置，</span><br>            <span class="hljs-comment">//前一个位置才小于pivot</span><br>            swap(nums, left, low - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//交换后要low的前面两个位置才会小于pivot</span><br>            <span class="hljs-comment">//递归排序小于pivot的数组</span><br>            quickSort(nums, left, low - <span class="hljs-number">2</span>);<br>            <span class="hljs-comment">//此时high位于等于pivot的最后一个位置</span><br>            <span class="hljs-comment">//high+1到right为大于pivot的位置</span><br>            quickSort(nums, high + <span class="hljs-number">1</span>, right);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        arr[i] = arr[j];<br>        arr[j] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>性能分析：和二路快排差不多，慢了一点，可能是没有很多重复值的测试用例</p><center><img src="/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92%E6%95%88%E7%8E%87.png" class=""></center><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h3><p>一般情况只需要掌握二路快排就够了，但是三路快排的思想要掌握，且在一些特殊情况很有用，如很多重复值的数组排序，贴一张截图，完成快速排序学习！！！</p><center><img src="/2020/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/%E6%80%BB%E7%BB%931.png" class=""></center>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    <url>/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文转自 <a href="http://www.guoyaohua.com/sorting.html">十大经典排序算法最强总结（含Java、Python码实现）</a> </p><p>代码自己理解实现，掌握算法</p><p>学艺不精，如果有错误请在关于页通过QQ或邮箱联系我</p></blockquote><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>排序算法可以分为：</p><ul><li>内部排序 ：数据记录在内存中进行排序。</li><li><a href="https://baike.baidu.com/item/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F/10595890?fr=aladdin">外部排序</a> ：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li></ul><p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等，本文只讲解内部排序算法。用一张图概括：</p><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/sort1.png" class="" title="各种排序比较"></center><p><strong>图片名词解释</strong>：</p><ul><li><code>n</code>：数据规模</li><li><code>k</code>：“桶”的个数</li><li><code>In-place</code>：占用常数内存，不占用额外内存</li><li><code>Out-place</code>：占用额外内存</li></ul><p><strong>术语说明</strong></p><ul><li>稳定：如果A原本在B前面，而A&#x3D;B，排序之后A仍然在B的前面。</li><li>不稳定：如果A原本在B的前面，而A&#x3D;B，排序之后A可能会出现在B的后面。</li><li>内排序：所有排序操作都在内存中完成。</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li><li>时间复杂度： 定性描述一个算法执行所耗费的时间。</li><li>空间复杂度：定性描述一个算法执行所需内存的大小。</li></ul><h4 id="1-1-算法分类"><a href="#1-1-算法分类" class="headerlink" title="1.1 算法分类"></a>1.1 算法分类</h4><p>十种常见排序算法可以分类两大类别：<strong>比较类排序</strong>和<strong>非比较类排序</strong>。</p><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/sort2.png" class="" title="排序分类"></center><p>常见的快<strong>速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>以及<strong>冒泡排序</strong>等都属于<strong>比较类排序算法</strong>。<strong>比较类排序</strong>是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破<code> O(nlogn)</code>，因此也称为<strong>非线性时间比较类排序</strong>。在<strong>冒泡排序</strong>之类的排序中，问题规模为 <code>n</code>，又因为需要比较 <code>n </code>次，所以平均时间复杂度为 <code>O(n²)</code>。在<strong>归并排序</strong>、<strong>快速排序</strong>之类的排序中，问题规模通过分治法消减为 <code>logn </code>次，所以时间复杂度平均 <code>O(nlogn)</code>。</p><p><strong>比较类排序</strong>的<strong>优势</strong>是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><p>而<strong>计数排序</strong>、<strong>基数排序</strong>、<strong>桶排序</strong>则属于<strong>非比较类排序算法</strong>。<strong>非比较排序</strong>不通过比较来决定元素间的相对次序，而是通过确定每个元素之前，应该有多少个元素来排序。<br>由于它可以突破基于比较排序的时间下界，以线性时间运行，因此称为<strong>线性时间非比较类排序</strong>。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 <code>O(n)</code>。</p><p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p><h2 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2 排序算法"></a>2 排序算法</h2><h3 id="2-1-冒泡排序-Bubble-Sort"><a href="#2-1-冒泡排序-Bubble-Sort" class="headerlink" title="2.1 冒泡排序(Bubble Sort)"></a>2.1 冒泡排序(Bubble Sort)</h3><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="2-1-1-算法步骤"><a href="#2-1-1-算法步骤" class="headerlink" title="2.1.1 算法步骤"></a>2.1.1 算法步骤</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><h4 id="2-1-2-图解算法"><a href="#2-1-2-图解算法" class="headerlink" title="2.1.2 图解算法"></a>2.1.2 图解算法</h4><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/bubble_sort.gif" class="" title="冒泡排序"></center><h4 id="2-1-3-代码实现"><a href="#2-1-3-代码实现" class="headerlink" title="2.1.3 代码实现"></a>2.1.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 冒泡排序</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 需要排序的数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-type">boolean</span> flag;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>        <span class="hljs-comment">// 用来判断此次循环是否发生数据交换</span><br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - i - <span class="hljs-number">1</span>; j++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-comment">// 交换顺序</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[j + <span class="hljs-number">1</span>];<br>                arr[j + <span class="hljs-number">1</span>] = arr[j];<br>                arr[j] = temp;<br>                <span class="hljs-comment">// 发生交换后置为false</span><br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag)&#123;<br>            <span class="hljs-comment">// 没有发生交换则终止循环</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处对代码做了一个小优化，加入了<code>flag</code>，目的是将算法的最佳时间复杂度优化为<code>O(n)</code>，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是<code>O(n)</code></p><h4 id="2-1-4-冒泡排序算法分析"><a href="#2-1-4-冒泡排序算法分析" class="headerlink" title="2.1.4 冒泡排序算法分析"></a>2.1.4 冒泡排序算法分析</h4><ul><li>稳定性：稳定</li><li>时间复杂度 ：最佳：<code>O(n)</code> ，最差：<code>O(n2)</code>， 平均：<code>O(n2)</code></li><li>空间复杂度 ：<code>O(1)</code></li><li>排序方式 ：<code>In-place</code></li></ul><h3 id="2-2-选择排序-Selection-Sort"><a href="#2-2-选择排序-Selection-Sort" class="headerlink" title="2.2 选择排序(Selection Sort)"></a>2.2 选择排序(Selection Sort)</h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是<code>O(n²)</code>的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="2-2-1-算法步骤"><a href="#2-2-1-算法步骤" class="headerlink" title="2.2.1 算法步骤"></a>2.2.1 算法步骤</h4><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第 2 步，直到所有元素均排序完毕。</li></ol><h4 id="2-2-2-图解算法"><a href="#2-2-2-图解算法" class="headerlink" title="2.2.2 图解算法"></a>2.2.2 图解算法</h4><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/selection_sort.gif" class="" title="选择排序"></center><h4 id="2-2-3-代码实现"><a href="#2-2-3-代码实现" class="headerlink" title="2.2.3 代码实现"></a>2.2.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 选择排序</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 需要排序的数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; arr.length; j++)&#123;<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[i])&#123;<br>                minIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//交换</span><br>        <span class="hljs-keyword">if</span>(minIndex != i)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[minIndex];<br>            arr[minIndex] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-4-选择排序算法分析"><a href="#2-2-4-选择排序算法分析" class="headerlink" title="2.2.4 选择排序算法分析"></a>2.2.4 选择排序算法分析</h4><ul><li><p>稳定性：不稳定</p><blockquote><p>例子：</p><p>排序前：8 4* 7 4 1 3</p><p>排序后：1 3 4 4* 7 8</p></blockquote></li><li><p>时间复杂度 ：最佳：<code>O(n2)</code> ，最差：<code>O(n2)</code>， 平均：<code>O(n2)</code></p></li><li><p>空间复杂度 ：<code>O(1)</code></p></li><li><p>排序方式 ：<code>In-place</code></p></li></ul><h3 id="2-3-插入排序-Insertion-Sort"><a href="#2-3-插入排序-Insertion-Sort" class="headerlink" title="2.3 插入排序(Insertion Sort)"></a>2.3 插入排序(Insertion Sort)</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 <code>in-place</code> 排序（即只需用到 <code>O(1)</code> 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><h4 id="2-3-1-算法步骤"><a href="#2-3-1-算法步骤" class="headerlink" title="2.3.1 算法步骤"></a>2.3.1 算法步骤</h4><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2~5。</li></ol><h4 id="2-3-2-图解算法"><a href="#2-3-2-图解算法" class="headerlink" title="2.3.2 图解算法"></a>2.3.2 图解算法</h4><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/insertion_sort.gif" class="" title="插入排序"></center><h4 id="2-3-3-代码实现"><a href="#2-3-3-代码实现" class="headerlink" title="2.3.3 代码实现"></a>2.3.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 插入排序</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 需要排序的数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertionSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-keyword">while</span>(pre &gt; <span class="hljs-number">0</span> &amp;&amp; temp &lt; arr[pre - <span class="hljs-number">1</span>])&#123;<br>            arr[pre] = arr[pre - <span class="hljs-number">1</span>];<br>            --pre;<br>        &#125;<br>        arr[pre] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-4-插入排序算法分析"><a href="#2-3-4-插入排序算法分析" class="headerlink" title="2.3.4 插入排序算法分析"></a>2.3.4 插入排序算法分析</h4><p>稳定性：稳定<br>时间复杂度 ：最佳：<code>O(n)</code> ，最差：<code>O(n2)</code>， 平均：<code>O(n2)</code><br>空间复杂度 ：<code>O(1)</code><br>排序方式 ：<code>In-place</code></p><h3 id="2-4-希尔排序-Shell-Sort"><a href="#2-4-希尔排序-Shell-Sort" class="headerlink" title="2.4 希尔排序(Shell Sort)"></a>2.4 希尔排序(Shell Sort)</h3><p>希尔排序是希尔 (Donald Shell) 于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法，同时该算法是冲破 <code>O(n²)</code> 的第一批算法之一。</p><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p><h4 id="2-4-1-算法步骤"><a href="#2-4-1-算法步骤" class="headerlink" title="2.4.1 算法步骤"></a>2.4.1 算法步骤</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量 <code>gap=length/2</code>，缩小增量继续以 <code>gap = gap/2</code> 的方式，这种增量选择我们可以用一个序列来表示，<code>&#123;n/2, (n/2)/2, ..., 1&#125;</code>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列 <code>&#123;t1, t2, …, tk&#125;</code>，其中 <code>(ti &gt; tj, i &lt; j, tk = 1)</code>；</li><li>按增量序列个数 <code>k</code>，对序列进行 <code>k</code> 趟排序；</li><li>每趟排序，根据对应的增量<code>t</code>，将待排序列分割成若干长度为<code>m</code>的子序列，分别对各子表进行直接<strong>插入排序</strong>。仅增量因子为 <code>1</code> 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="2-4-2-图解算法"><a href="#2-4-2-图解算法" class="headerlink" title="2.4.2 图解算法"></a>2.4.2 图解算法</h4><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/shell_sort.png" class="" title="希尔排序"></center><h4 id="2-4-3-代码实现"><a href="#2-4-3-代码实现" class="headerlink" title="2.4.3 代码实现"></a>2.4.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 希尔排序</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 需要排序的数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shellSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-comment">//增量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">gap</span> <span class="hljs-operator">=</span> len;<br>    <span class="hljs-keyword">while</span>(gap &gt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//计算增量</span><br>        gap /= <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> gap; i &lt; len; i++)&#123;<br>            <span class="hljs-comment">//此循环体相当于插入排序</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> i - gap;<br>            <span class="hljs-keyword">while</span> (pre &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[pre] &gt; temp)&#123;<br>                arr[pre + gap] = arr[pre];<br>                pre -= gap;<br>            &#125;<br>            arr[pre + gap] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-4-希尔排序算法分析"><a href="#2-4-4-希尔排序算法分析" class="headerlink" title="2.4.4 希尔排序算法分析"></a>2.4.4 希尔排序算法分析</h4><ul><li>稳定性：不稳定<blockquote><p>由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。对于排序算法，所谓的不稳定指的就是相同元素在排序过程中被移动</p><p>如：</p><p>排序前： 4* 4 1 3 2</p><p>排序后： 1 2 3 4 4*</p></blockquote></li><li>时间复杂度 ：最佳：<code>O(nlogn)</code>， 最差：<code>O(n2)</code> 平均：<code>O(nlogn)</code></li><li>空间复杂度 ：<code>O(1)</code></li></ul><h3 id="2-5-归并排序-Merge-Sort"><a href="#2-5-归并排序-Merge-Sort" class="headerlink" title="2.5 归并排序(Merge Sort)"></a>2.5 归并排序(Merge Sort)</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用<strong>分治法</strong> (Divide and Conquer) 的一个非常典型的应用。归并排序是一种<strong>稳定</strong>的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 <code>2 - 路</code>归并。</p><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 <code>O(nlogn)</code> 的时间复杂度。代价是需要额外的内存空间。</p><h4 id="2-5-1-算法步骤"><a href="#2-5-1-算法步骤" class="headerlink" title="2.5.1 算法步骤"></a>2.5.1 算法步骤</h4><p>归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：</p><ol><li>如果输入内只有一个元素，则直接返回，否则将长度为 n 的输入序列分成两个长度为 n&#x2F;2 的子序列；</li><li>分别对这两个子序列进行归并排序，使子序列变为有序状态；</li><li>设定两个指针，分别指向两个已经排序子序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</li><li>重复步骤 3 ~4 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h4 id="2-5-2-图解算法"><a href="#2-5-2-图解算法" class="headerlink" title="2.5.2 图解算法"></a>2.5.2 图解算法</h4><center>    <img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/merge_sort.gif" class="" title="归并排序"></center><h4 id="2-5-3-代码实现"><a href="#2-5-3-代码实现" class="headerlink" title="2.5.3 代码实现"></a>2.5.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 归并排序</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 需要排序的数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] mergeSort(<span class="hljs-type">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">if</span>(arr.length == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> arr.length / <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//对半拷贝数组</span><br>    <span class="hljs-type">int</span>[] arr1 = Arrays.copyOfRange(arr, <span class="hljs-number">0</span>, mid);<br>    <span class="hljs-type">int</span>[] arr2 = Arrays.copyOfRange(arr, mid, arr.length);<br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-keyword">return</span> merge(mergeSort(arr1), mergeSort(arr2));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 合并两个数组</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr1 数组1</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr2 数组2</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] merge(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2) &#123;<br>    <span class="hljs-comment">//结果数组</span><br>    <span class="hljs-type">int</span>[] resArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr1.length + arr2.length];<br>    <span class="hljs-comment">//三个数组的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">indexRes</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, indexA1 = <span class="hljs-number">0</span>, indexA2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(indexA1 &lt; arr1.length &amp;&amp; indexA2 &lt; arr2.length)&#123;<br>        <span class="hljs-keyword">if</span>(arr1[indexA1] &lt; arr2[indexA2])&#123;<br>            resArr[indexRes++] = arr1[indexA1++];<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            resArr[indexRes++] = arr2[indexA2++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//arr1可能没遍历完</span><br>    <span class="hljs-keyword">while</span> (indexA1 &lt; arr1.length)&#123;<br>        resArr[indexRes++] = arr1[indexA1++];<br>    &#125;<br>    <span class="hljs-comment">//arr2可能没遍历完</span><br>    <span class="hljs-keyword">while</span> (indexA2 &lt; arr2.length)&#123;<br>        resArr[indexRes++] = arr2[indexA2++];<br>    &#125;<br>    <span class="hljs-keyword">return</span> resArr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-4-归并排序算法分析"><a href="#2-5-4-归并排序算法分析" class="headerlink" title="2.5.4 归并排序算法分析"></a>2.5.4 归并排序算法分析</h4><ul><li>稳定性：稳定</li><li>时间复杂度 ：最佳：<code>O(nlogn)</code>， 最差：<code>O(nlogn)</code>， 平均：<code>O(nlogn)</code></li><li>空间复杂度 ：<code>O(n)</code></li></ul><h3 id="2-6-快速排序-Quick-Sort"><a href="#2-6-快速排序-Quick-Sort" class="headerlink" title="2.6 快速排序(Quick Sort)"></a>2.6 快速排序(Quick Sort)</h3><p>快速排序用到了<strong>分治思想</strong>，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并<strong>不稳定</strong>。</p><p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p><h4 id="2-6-1-算法步骤"><a href="#2-6-1-算法步骤" class="headerlink" title="2.6.1 算法步骤"></a>2.6.1 算法步骤</h4><p>快速排序使用分治法（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p><ol><li>从序列中随机挑出一个元素，做为 “基准”(pivot)；</li><li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的3. 摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li></ol><h4 id="2-6-2-图解算法"><a href="#2-6-2-图解算法" class="headerlink" title="2.6.2 图解算法"></a>2.6.2 图解算法</h4><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/random_quick_sort.gif" class="" title="快速排序"></center><h4 id="2-6-3-代码实现"><a href="#2-6-3-代码实现" class="headerlink" title="2.6.3 代码实现"></a>2.6.3 代码实现</h4><blockquote><p>代码参考： <a href="https://www.runoob.com/w3cnote/quick-sort-2.html">https://www.runoob.com/w3cnote/quick-sort-2.html</a></p><p>下列代码是默认将第一个数设为基准</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 快速排序</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 待排序数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> low 第一个位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> high 末位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] quickSort(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)&#123;<br>        <span class="hljs-comment">//划分</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">partitionIndex</span> <span class="hljs-operator">=</span> partition(arr, low, high);<br>        quickSort(arr, low, partitionIndex - <span class="hljs-number">1</span>);<br>        quickSort(arr, partitionIndex + <span class="hljs-number">1</span>, high);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 划分方法，将数组变为基准值前面比基准值小，后面比基准值大</span><br><span class="hljs-comment">* 将数组的第一个数设为基准</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> low 第一个位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> high 末位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>    <span class="hljs-comment">//将第一个数设为基准,记录其索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> low;<br>    <span class="hljs-comment">//记录比基准值大的数的指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> low + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> low + <span class="hljs-number">1</span>; i &lt;= high; i++) &#123;<br>        <span class="hljs-keyword">if</span>(arr[i] &lt; arr[pivot])&#123;<br>            <span class="hljs-comment">//如果当前的值比基准值要小，与大于基准值的数交换位置</span><br>            swap(arr, index, i);<br>            <span class="hljs-comment">//索引加一</span><br>            index++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//交换基准值和小于基准值的最后一个值的位置</span><br>    swap(arr, pivot, --index);<br>    <span class="hljs-comment">//返回基准值现在得位置</span><br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 交换数组两个元素位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> i 位置1</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> j 位置2</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>    arr[i] = arr[j];<br>    arr[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6-4-快速排序算法分析"><a href="#2-6-4-快速排序算法分析" class="headerlink" title="2.6.4 快速排序算法分析"></a>2.6.4 快速排序算法分析</h4><ul><li>稳定性 ：不稳定</li><li>时间复杂度 ：最佳：<code>O(nlogn)</code>， 最差：<code>O(nlogn)</code>，平均：<code>O(nlogn)</code></li><li>空间复杂度 ：<code>O(nlogn)</code></li></ul><h3 id="2-7-堆排序-Heap-Sort"><a href="#2-7-堆排序-Heap-Sort" class="headerlink" title="2.7 堆排序(Heap Sort)"></a>2.7 堆排序(Heap Sort)</h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的值总是小于（或者大于）它的父节点。</p><h4 id="2-7-1-算法步骤"><a href="#2-7-1-算法步骤" class="headerlink" title="2.7.1 算法步骤"></a>2.7.1 算法步骤</h4><ol><li>将初始待排序列 <code>(R1, R2, ……, Rn)</code> 构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素 <code>R[1]</code> 与最后一个元素 <code>R[n]</code> 交换，此时得到新的无序区 <code>(R1, R2, ……, Rn-1)</code> 和新的有序区 <code>(Rn)</code>, 且满足 <code>R[1, 2, ……, n-1]&lt;=R[n]</code>；</li><li>由于交换后新的堆顶 <code>R[1]</code>可能违反堆的性质，因此需要对当前无序区<code>(R1, R2, ……, Rn-1)</code> 调整为新堆，然后再次将 <code>R [1]</code> 与无序区最后一个元素交换，得到新的无序区 <code>(R1, R2, ……, Rn-2)</code> 和新的有序区 <code>(Rn-1, Rn)</code>。不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成。</li></ol><h4 id="2-7-2-图解算法"><a href="#2-7-2-图解算法" class="headerlink" title="2.7.2 图解算法"></a>2.7.2 图解算法</h4><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/heap_sort.gif" class="" title="堆排序"></center><h4 id="2-7-3-代码实现"><a href="#2-7-3-代码实现" class="headerlink" title="2.7.3 代码实现"></a>2.7.3 代码实现</h4><blockquote><p>代码参考：<a href="https://www.cnblogs.com/luomeng/p/10618709.html">https://www.cnblogs.com/luomeng/p/10618709.html</a></p><p>以下代码省略了void swap(int[] arr, int i, int j)方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 堆排序</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 待排序数组</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">heapSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-comment">//创建大根堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (len/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>); i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>        adjustHeap(arr, i, len);<br>    &#125;<br>    <span class="hljs-comment">//调整堆结构+交换堆顶元素与末尾元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">//将堆顶元素与末尾元素进行交换</span><br>        swap(arr, <span class="hljs-number">0</span>, i);<br>        <span class="hljs-comment">//重新对堆进行调整</span><br>        adjustHeap(arr, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 调整堆</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 待排序数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> parent 父节点</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> len 待排序数组长度</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> len)</span> &#123;<br>    <span class="hljs-comment">//左孩子</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//右孩子</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * parent + <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//记录父节点，左右孩子中最大值的索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">largest</span> <span class="hljs-operator">=</span> parent;<br>    <span class="hljs-comment">//如果存在右孩子且大于父节点，将索引值设为右孩子的索引</span><br>    <span class="hljs-keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;<br>        largest = right;<br>    &#125;<br>    <span class="hljs-comment">//如果存在左孩子且大于父节点或大于右孩子，将索引值设为左孩子的索引</span><br>    <span class="hljs-keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;<br>        largest = left;<br>    &#125;<br>    <span class="hljs-comment">//如果此时最大值的索引已经改变，那么交换父节点左右孩子节点的数值</span><br>    <span class="hljs-keyword">if</span> (largest != parent) &#123;<br>        swap(arr, largest, parent);<br>        <span class="hljs-comment">//交换后，对以左右孩子为根的树会造成影响，递归进行左或右孩子为根的树进行调整</span><br>        adjustHeap(arr, largest, len);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-7-4-堆排序算法分析"><a href="#2-7-4-堆排序算法分析" class="headerlink" title="2.7.4 堆排序算法分析"></a>2.7.4 堆排序算法分析</h4><ul><li>稳定性 ：不稳定</li><li>时间复杂度 ：最佳：<code>O(nlogn)</code>， 最差：<code>O(nlogn)</code>， 平均：<code>O(nlogn)</code></li><li>空间复杂度 ：<code>O(1)</code></li></ul><h3 id="2-8-计数排序-Counting-Sort"><a href="#2-8-计数排序-Counting-Sort" class="headerlink" title="2.8 计数排序(Counting Sort)"></a>2.8 计数排序(Counting Sort)</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是<strong>有确定范围的整数</strong>。</p><p>计数排序 (Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组 <code>C</code>，其中第 i 个元素是待排序数组 <code>A</code> 中值等于 <code>i</code> 的元素的个数。然后根据数组 <code>C</code> 来将 <code>A</code> 中的元素排到正确的位置。它只能对整数进行排序。</p><h4 id="2-8-1-算法步骤"><a href="#2-8-1-算法步骤" class="headerlink" title="2.8.1 算法步骤"></a>2.8.1 算法步骤</h4><ol><li>找出数组中的最大值 <code>max</code>、最小值 <code>min</code>；</li><li>创建一个新数组 <code>C</code>，其长度是 <code>max-min+1</code>，其元素默认值都为 <code>0</code>；</li><li>遍历原数组 <code>A</code>中的元素 <code>A[i]</code>，以 <code>A[i]-min</code> 作为 <code>C</code> 数组的索引，以 <code>A[i]</code> 的值在 <code>A</code> 中元素出现次数作为 <code>C[A[i]-min]</code> 的值；</li><li>对 <code>C</code> 数组变形，新元素的值是该元素与前一个元素值的和，即当 <code>i&gt;1</code> 时 <code>C[i] = C[i] + C[i-1]</code>；</li><li>创建结果数组 <code>R</code>，长度和原始数组一样。</li><li><strong>从后向前</strong>遍历原始数组 <code>A</code> 中的元素 <code>A[i]</code>，使用 <code>A[i]</code> 减去最小值 <code>min</code> 作为索引，在计数数组 <code>C</code> 中找到对应的值 <code>C[A[i]-min]</code>，<code>C[A[i]-min]-1</code> 就是 <code>A[i]</code> 在结果数组 <code>R</code> 中的位置，做完上述这些操作，将 <code>count[A[i]-min]</code> 减小 <code>1</code>。</li></ol><h4 id="2-8-2-图解算法"><a href="#2-8-2-图解算法" class="headerlink" title="2.8.2 图解算法"></a>2.8.2 图解算法</h4><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/counting_sort.gif" class="" title="计数排序"></center><h4 id="2-8-3-代码实现"><a href="#2-8-3-代码实现" class="headerlink" title="2.8.3 代码实现"></a>2.8.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 计数排序</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 待排序数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] countingSort(<span class="hljs-type">int</span>[] arr)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length;<br>    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>    <span class="hljs-comment">//记录数组中的最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//记录数组中的最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//遍历找出最大值和最小值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        <span class="hljs-keyword">if</span>(num &gt; max)&#123;<br>            max = num;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (num &lt; min)&#123;<br>            min = num;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//计数数组</span><br>    <span class="hljs-type">int</span>[] countArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[max - min + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//排序后的结果数组</span><br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[len];<br>    <span class="hljs-comment">//统计数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        countArr[num - min] += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//计算是第几个数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; countArr.length; i++) &#123;<br>        <span class="hljs-comment">//值是该元素与前一个元素值的和</span><br>        countArr[i] += countArr[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-comment">//开始排序操作</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">//计算索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> countArr[arr[i] - min] - <span class="hljs-number">1</span>;<br>        res[index] = arr[i];<br>        <span class="hljs-comment">//数量减 1</span><br>        --countArr[arr[i] - min];<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-8-4-计数排序算法分析"><a href="#2-8-4-计数排序算法分析" class="headerlink" title="2.8.4 计数排序算法分析"></a>2.8.4 计数排序算法分析</h4><p>当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 <code>O(n+k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 <code>1</code>），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。</p><ul><li>稳定性：稳定</li><li>时间复杂度：最佳：<code>O(n+k)</code> 最差：<code>O(n+k)</code> 平均：<code>O(n+k)</code></li><li>空间复杂度：<code>O(k)</code></li></ul><h3 id="2-9-桶排序-Bucket-Sort"><a href="#2-9-桶排序-Bucket-Sort" class="headerlink" title="2.9 桶排序(Bucket Sort)"></a>2.9 桶排序(Bucket Sort)</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行。</p><h4 id="2-9-1-算法步骤"><a href="#2-9-1-算法步骤" class="headerlink" title="2.9.1 算法步骤"></a>2.9.1 算法步骤</h4><ol><li>设置一个 BucketSize，作为每个桶所能放置多少个不同数值；</li><li>遍历输入数据，并且把数据依次映射到对应的桶里去；</li><li>对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从非空桶里把排好序的数据拼接起来。</li></ol><h4 id="2-9-2-图解算法"><a href="#2-9-2-图解算法" class="headerlink" title="2.9.2 图解算法"></a>2.9.2 图解算法</h4><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/bucket_sort.gif" class="" title="桶排序"></center><h4 id="2-9-3-代码实现"><a href="#2-9-3-代码实现" class="headerlink" title="2.9.3 代码实现"></a>2.9.3 代码实现</h4><blockquote><p>代码参考：<a href="https://www.runoob.com/w3cnote/bucket-sort.html">https://www.runoob.com/w3cnote/bucket-sort.html</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 桶排序</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 待排序数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> bucketSize 桶的尺寸</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] bucketSort(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> bucketSize)&#123;<br>    <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span> || bucketSize == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-comment">//获取最大值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">minValue</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">//获取最小值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : arr) &#123;<br>        <span class="hljs-keyword">if</span> (value &lt; minValue) &#123;<br>            minValue = value;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &gt; maxValue) &#123;<br>            maxValue = value;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//计算桶的数量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">bucketCount</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//创建多个桶</span><br>    <span class="hljs-type">int</span>[][] buckets = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[bucketCount][<span class="hljs-number">0</span>];<br>    <span class="hljs-comment">// 利用映射函数将数据分配到各个桶中</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>        <span class="hljs-comment">//根据映射关系计算位于第几个桶</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) Math.floor((num - minValue) / bucketSize);<br>        <span class="hljs-comment">//添加到index桶的末尾</span><br>        buckets[index] = arrAppend(buckets[index], num);<br>    &#125;<br>    <span class="hljs-comment">//结果数组的索引</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">arrIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] bucket : buckets) &#123;<br>        <span class="hljs-keyword">if</span> (bucket.length &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果桶中没有数据，执行下一循环</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// 对每个桶进行排序，这里使用了插入排序</span><br>        insertionSort(bucket);<br>        <span class="hljs-comment">// 将桶中的数组添加到结果中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : bucket) &#123;<br>            arr[arrIndex++] = value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 自动扩容，并保存数据</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> arr 数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> value 需要添加进入数组的数</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arrAppend(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> value) &#123;<br>    arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);<br>    arr[arr.length - <span class="hljs-number">1</span>] = value;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-9-4-桶排序算法分析"><a href="#2-9-4-桶排序算法分析" class="headerlink" title="2.9.4 桶排序算法分析"></a>2.9.4 桶排序算法分析</h4><ul><li>稳定性 ：稳定</li><li>时间复杂度 ：最佳：<code>O(n+k)</code> 最差：<code>O(n²)</code> 平均：<code>O(n+k)</code></li><li>空间复杂度 ：<code>O(k)</code></li></ul><h3 id="2-10-基数排序-Radix-Sort"><a href="#2-10-基数排序-Radix-Sort" class="headerlink" title="2.10 基数排序(Radix Sort)"></a>2.10 基数排序(Radix Sort)</h3><p>基数排序也是非比较的排序算法，对元素中的每一位数字进行排序，从最低位开始排序，复杂度为 O(n×k)，n 为数组长度，k 为数组中元素的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h4 id="2-10-1-算法步骤"><a href="#2-10-1-算法步骤" class="headerlink" title="2.10.1 算法步骤"></a>2.10.1 算法步骤</h4><p>1。 取得数组中的最大数，并取得位数，即为迭代次数 <code>N</code>（例如：数组中最大数值为 <code>1000</code>，则 <code>N=4</code>）；<br>2. <code>A</code> 为原始数组，从最低位开始取每个位组成 <code>radix</code> 数组；<br>3. 对 <code>radix</code> 进行计数排序（利用计数排序适用于小范围数的特点）；<br>4. 将 <code>radix</code> 依次赋值给原数组；<br>5. 重复 2~4 步骤 <code>N</code> 次</p><h4 id="2-10-2-图解算法"><a href="#2-10-2-图解算法" class="headerlink" title="2.10.2 图解算法"></a>2.10.2 图解算法</h4><center><img src="/2020/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/radix_sort.gif" class="" title="基数排序"></center><h4 id="2-10-3-代码实现"><a href="#2-10-3-代码实现" class="headerlink" title="2.10.3 代码实现"></a>2.10.3 代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自动扩容，并保存数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr 数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 需要添加进入数组的数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] arrAppend(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> value) &#123;<br>        arr = Arrays.copyOf(arr, arr.length + <span class="hljs-number">1</span>);<br>        arr[arr.length - <span class="hljs-number">1</span>] = value;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基数排序</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr 待排序数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">radixSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-keyword">if</span> (arr.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//最大值的位数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//最大值</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxValue</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//找到最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>            <span class="hljs-keyword">if</span> (num &gt; maxValue) &#123;<br>                maxValue = num;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//判断最大值有多少位</span><br>        <span class="hljs-keyword">while</span> (maxValue / <span class="hljs-number">10</span> != <span class="hljs-number">0</span>) &#123;<br>            maxValue = maxValue / <span class="hljs-number">10</span>;<br>            N += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//开始排序操作</span><br>        <span class="hljs-comment">// 第一次循环可以让数组内部的一位的数字变得相对有序，当然这其中会穿插的其余位数的数字；</span><br>        <span class="hljs-comment">// 第二次循环就是一位，二位的数字相对有序</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>            <span class="hljs-comment">//数组的一维表示可能的余数0-9</span><br>            <span class="hljs-type">int</span>[][] radixes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>][<span class="hljs-number">0</span>];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> (num / (<span class="hljs-type">int</span>) Math.pow(<span class="hljs-number">10</span>, i)) % <span class="hljs-number">10</span>;<br>                <span class="hljs-comment">//添加到余数对应的二维数组的一维数组</span><br>                radixes[idx] = arrAppend(radixes[idx], num);<br>            &#125;<br>            <span class="hljs-comment">//结果数组的索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//改边原数组，让原数组中i位大小的数字1相对有序</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] radix : radixes) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : radix) &#123;<br>                    arr[idx++] = num;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="2-10-4-基数排序算法分析"><a href="#2-10-4-基数排序算法分析" class="headerlink" title="2.10.4 基数排序算法分析"></a>2.10.4 基数排序算法分析</h4><ul><li>稳定性：稳定</li><li>时间复杂度：最佳：<code>O(n×k)</code> 最差：<code>O(n×k)</code> 平均：<code>O(n×k)</code></li><li>空间复杂度：<code>O(n+k)</code></li></ul><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>算法</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解synchronized</title>
    <link href="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/"/>
    <url>/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本学习笔记来自教程  <a href="https://www.bilibili.com/video/BV1aJ411V763/">Java面试热点问题，synchronized原理剖析与优化</a></p></blockquote><h1 id="深入学习并发编程中的synchronized"><a href="#深入学习并发编程中的synchronized" class="headerlink" title="深入学习并发编程中的synchronized"></a>深入学习并发编程中的synchronized</h1><h2 id="第一章：并发编程中的三个问题"><a href="#第一章：并发编程中的三个问题" class="headerlink" title="第一章：并发编程中的三个问题"></a>第一章：并发编程中的三个问题</h2><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><hr><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>学习什么是可见性问题</p><h4 id="可见性概念"><a href="#可见性概念" class="headerlink" title="可见性概念"></a>可见性概念</h4><p>可见性（Visibility）：是指一个线程对共享变量进行修改,另一个先立即得到修改后的最新值。</p><h4 id="可见性演示"><a href="#可见性演示" class="headerlink" title="可见性演示"></a>可见性演示</h4><p>案例演示：一个线程根据boolean类型的标记flag, while循环,另一个线程改变这个flag变量的值,另<br>一个线程并不会停止循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo01_concurrent_problem;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可见性（Visibility）：是指一个线程对共享变量进行修改,另一个线程立即得到修改后的最新值</span><br><span class="hljs-comment"> * 可见性演示</span><br><span class="hljs-comment"> *      一个线程对共享变量的修改,另一个线程不能立即得到最新值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01Visibility</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//线程2修改后线程1并没有结束,程序一直在运行</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run)&#123;<br><br>            &#125;<br>        &#125;);<br><br>        t1.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            run = <span class="hljs-literal">false</span>;<br>            System.out.println(<span class="hljs-string">&quot;时间到,线程2设置为false&quot;</span>);<br>        &#125;);<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>并发编程时,会出现可见性问题,当一个线程对共享变量进行了修改,另外的线程并没有立即看到修改<br>后的最新值。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><hr><h4 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h4><p>学习什么是原子性问题</p><h4 id="原子性概念"><a href="#原子性概念" class="headerlink" title="原子性概念"></a>原子性概念</h4><p>原子性（Atomicity）：在一次或多次操作中,要么所有的操作都执行并且不会受其他因素干扰而中<br>断,要么所有的操作都不执行。</p><h4 id="原子性演示"><a href="#原子性演示" class="headerlink" title="原子性演示"></a>原子性演示</h4><p>案例演示:5个线程各执行1000次 i++;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo01_concurrent_problem;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 原子性（Atomicity）：在一次或多次操作中,要么所有的操作都执行并且不会受其他因素干扰而中</span><br><span class="hljs-comment"> * 断,要么所有的操作都不执行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02Atomicity</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">increment</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                number++;<br>            &#125;<br>        &#125;;<br><br>        List&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(increment);<br>            t.start();<br>            list.add(t);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(Thread t : list)&#123;<br>            t.join();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;number = &quot;</span> + number);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用javap反汇编class文件,得到下面的字节码指令：</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/1.png" class=""></div>其中,对于 number++ 而言（number 为静态变量）,实际会产生如下的 JVM 字节码指令：<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">9: getstatic #12          // Field number:I<br>12: iconst_1<br>13: iadd<br>14: putstatic #12         // Field number:I<br></code></pre></td></tr></table></figure><p>由此可见number++是由多条语句组成,以上多条指令在一个线程的情况下是不会出问题的,但是在多<br>线程情况下就可能会出现问题。比如一个线程在执行13: iadd时,另一个线程又执行9: getstatic。会导<br>致两次number++,实际上只加了1。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>并发编程时,会出现原子性问题,当一个线程对共享变量操作到一半时,另外的线程也有可能来操作共<br>享变量,干扰了前一个线程的操作。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><hr><h4 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h4><p>学习什么是有序性问题</p><h4 id="有序性概念"><a href="#有序性概念" class="headerlink" title="有序性概念"></a>有序性概念</h4><p>有序性（Ordering）：是指程序中代码的执行顺序,Java在编译时和运行时会对代码进行优化,会导致<br>程序最终的执行顺序不一定就是我们编写代码时的顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="有序性演示"><a href="#有序性演示" class="headerlink" title="有序性演示"></a>有序性演示</h4><p>jcstress是java并发压测工具。<a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a><br>修改pom文件,添加依赖(后续依赖及插件一起加上)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">javac.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">javac.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">jcstress.version</span>&gt;</span>0.5<span class="hljs-tag">&lt;/<span class="hljs-name">jcstress.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">uberjar.name</span>&gt;</span>jcstress<span class="hljs-tag">&lt;/<span class="hljs-name">uberjar.name</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcstress-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jcstress.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">compilerVersion</span>&gt;</span>$&#123;javac.target&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">compilerVersion</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>$&#123;javac.target&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>$&#123;javac.target&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-shade-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>main<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>shade<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>$&#123;uberjar.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">transformers</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">transformer</span></span><br><span class="hljs-tag">                                    <span class="hljs-attr">implementation</span>=<span class="hljs-string">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>org.openjdk.jcstress.Main<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">transformer</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">transformer</span> <span class="hljs-attr">implementation</span>=<span class="hljs-string">&quot;org.apache.maven.plugins.shade.resource.AppendingTransformer&quot;</span>&gt;</span><br>                                <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>META-INF/TestList<span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>                            <span class="hljs-tag">&lt;/<span class="hljs-name">transformer</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">transformers</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码：<br>Test03Orderliness.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo01_concurrent_problem;<br><br><span class="hljs-keyword">import</span> org.openjdk.jcstress.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 有序性</span><br><span class="hljs-comment"> * 是指程序中代码的执行顺序,Java在编译时和运行时会对代码进行优化,会导致</span><br><span class="hljs-comment"> * 程序最终的执行顺序不一定就是我们编写代码时的顺序。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 出现0的结果就是线程2执行顺序出现问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@JCStressTest</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span><br><span class="hljs-meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger&quot;)</span><br><span class="hljs-meta">@State</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03Orderliness</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//线程1</span><br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span>&#123;<br>        <span class="hljs-keyword">if</span>(ready)&#123;<br>            r.r1 = num + num;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r.r1 = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//线程2</span><br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span>&#123;<br>        num = <span class="hljs-number">2</span>;<br>        ready = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>I_Result 是一个对象,有一个属性r1 用来保存结果,在多线程情况下可能出现几种结果？ 情况1：线<br>程1先执行actor1,这时ready &#x3D; false,所以进入else分支结果为1。</li><li>情况2：线程2执行到actor2,执行了num &#x3D; 2;和ready &#x3D; true,线程1执行,这回进入 if 分支,结果为<br>4。</li><li>情况3：线程2先执行actor2,只执行num &#x3D; 2；但没来得及执行 ready &#x3D; true,线程1执行,还是进入<br>else分支,结果为1。</li><li><font color="red">还有一种结果0</font></li></ul><p>运行测试：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">mvn clean install<br>java -jar target/jcstress.jar<br></code></pre></td></tr></table></figure><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>程序代码在执行过程中的先后顺序,由于Java在编译期以及运行期的优化,导致了代码的执行顺序未必<br>就是开发者编写代码时的顺序。</p><h2 id="第二章：Java内存模型-JMM"><a href="#第二章：Java内存模型-JMM" class="headerlink" title="第二章：Java内存模型(JMM)"></a>第二章：Java内存模型(JMM)</h2><p>在介绍Java内存模型之前,先来看一下到底什么是计算机内存模型。</p><h3 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h3><hr><h4 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h4><p>学习计算机的主要组成</p><p>学习缓存的作用</p><h4 id="计算机结构简介"><a href="#计算机结构简介" class="headerlink" title="计算机结构简介"></a>计算机结构简介</h4><p>冯诺依曼,提出计算机由五大组成部分,输入设备,输出设备存储器,控制器,运算器。</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/2.png" class=""></div><h5 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h5><p>中央处理器,是计算机的控制和运算的核心,我们的程序最终都会变成指令让CPU去执行,处理程序中<br>的数据。</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/3.png" class=""></div><h5 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h5><p>我们的程序都是在内存中运行的,内存会保存程序运行时的数据,供CPU处理。</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/4.png" class=""></div><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h5><p>CPU的运算速度和内存的访问速度相差比较大。这就导致CPU每次操作内存都要耗费很多等待时间。内<br>存的读写速度成为了计算机运行的瓶颈。于是就有了在CPU和主内存之间增加缓存的设计。最靠近CPU<br>的缓存称为L1,然后依次是 L2,L3和主内存,CPU缓存模型如图下图所示。</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/5.png" class=""></div><p>CPU Cache分成了三个级别: L1, L2, L3。级别越小越接近CPU,速度也更快,同时也代表着容量越<br>小。</p><ol><li>L1是最接近CPU的,它容量最小,例如32K,速度最快,每个核上都有一个L1 Cache。</li><li>L2 Cache 更大一些,例如256K,速度要慢一些,一般情况下每个核上都有一个独立的L2 Cache。</li><li>L3 Cache是三级缓存中最大的一级,例如12MB,同时也是缓存中最慢的一级,在同一个CPU插槽<br>之间的核共享一个L3 Cache。</li></ol><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/6.png" class=""></div>Cache的出现是为了解决CPU直接访问内存效率低下问题的,程序在运行的过程中,CPU接收到指令后,它会最先向CPU中的一级缓存（L1 Cache）去寻找相关的数据,如果命中缓存,CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写人,当运算结束之后,再将CPUCache中的最新数据刷新到主内存当中,CPU通过直接访问Cache的方式替代直接访问主存的方式极大地提高了CPU 的吞吐能力。但是由于一级缓存（L1 Cache）容量较小,所以不可能每次都命中。这时CPU会继续向下一级的二级缓存（L2 Cache）寻找,同样的道理,当所需要的数据在二级缓存中也没有的话,会继续转向L3Cache、内存(主存)和硬盘。<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>计算机的主要组成CPU,内存,输入设备,输出设备。</p><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><hr><h4 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h4><p>学习Java内存模型的概念和作用</p><h4 id="Java内存模型的概念"><a href="#Java内存模型的概念" class="headerlink" title="Java内存模型的概念"></a>Java内存模型的概念</h4><p>Java Memory Molde (Java内存模型&#x2F;JMM),千万不要和Java内存结构混淆</p><p>关于“Java内存模型”的权威解释,请参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model-">https://download.oracle.com/otn-pub/jcp/memory_model-</a><br>1.0-pfd-spec-oth-JSpec&#x2F;memory_model-1_0-pfd-spec.pdf。</p><p>Java内存模型,是Java虚拟机规范中所定义的一种内存模型,Java内存模型是标准化的,屏蔽掉了底层<br>不同计算机的区别。</p><p>Java内存模型是一套规范,描述了Java程序中各种变量(线程共享变量)的访问规则,以及在JVM中将变量<br>存储到内存和从内存中读取变量这样的底层细节,具体如下。</p><ul><li><p>主内存</p><p> 主内存是所有线程都共享的,都能访问的。所有的共享变量都存储于主内存。</p></li><li><p>工作内存</p><p>每一个线程有自己的工作内存,工作内存只存储该线程对共享变量的副本。线程对变量的所有的操<br>作(读,取)都必须在工作内存中完成,而不能直接读写主内存中的变量,不同线程之间也不能直接<br>访问对方工作内存中的变量</p></li></ul><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/7.png" class=""></div><h4 id="Java内存模型的作用"><a href="#Java内存模型的作用" class="headerlink" title="Java内存模型的作用"></a>Java内存模型的作用</h4><p>Java内存模型是一套在多线程读写共享数据时,对共享数据的可见性、有序性、和原子性的规则和保<br>障。</p><p><code>synchronized</code>,<code>volatile</code></p><h4 id="CPU缓存-内存与Java内存模型的关系"><a href="#CPU缓存-内存与Java内存模型的关系" class="headerlink" title="CPU缓存,内存与Java内存模型的关系"></a>CPU缓存,内存与Java内存模型的关系</h4><p>通过对前面的CPU硬件内存架构、Java内存模型以及Java多线程的实现原理的了解,我们应该已经意识<br>到,多线程的执行最终都会映射到硬件处理器上进行执行。</p><p>但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概<br>念,并没有工作内存和主内存之分,也就是说Java内存模型对内存的划分对硬件内存并没有任何影响,<br>因为JMM只是一种抽象的概念,是一组规则,不管是工作内存的数据还是主内存的数据,对于计算机硬<br>件来说都会存储在计算机主内存中,当然也有可能存储到CPU缓存或者寄存器中,因此总体上来说,<br>Java内存模型和计算机硬件内存架构是一个相互交叉的关系,是一种抽象概念划分与真实物理硬件的交<br>叉。</p><p><font color="red">JMM内存模型与CPU硬件内存架构的关系：</font></p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/8.png" class=""></div><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>Java内存模型是一套规范,描述了Java程序中各种变量(线程共享变量)的访问规则,以及在JVM中将变量<br>存储到内存和从内存中读取变量这样的底层细节,Java内存模型是对共享数据的可见性、有序性、和原<br>子性的规则和保障。</p><h3 id="主内存与工作内存之间的交互"><a href="#主内存与工作内存之间的交互" class="headerlink" title="主内存与工作内存之间的交互"></a>主内存与工作内存之间的交互</h3><hr><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/9.png" class=""></div><h4 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h4><p>了解主内存与工作内存之间的数据交互过程</p><p>Java内存模型中定义了以下8种操作来完成,主内存与工作内存之间具体的交互协议,即一个变量如何<br>从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节,虚拟机实现时必须保证下面<br>提及的每一种操作都是原子的、不可再分的。</p><p>对应如下的流程图：</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/10.png" class=""></div><p>注意：</p><ol><li>如果对一个变量执行lock操作,将会清空工作内存中此变量的值</li><li>对一个变量执行unlock操作之前,必须先把此变量同步到主内存中</li></ol><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>主内存与工作内存之间的数据交互过程</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">lock -&gt; read -&gt; load -&gt; use -&gt; assign -&gt; store -&gt; write -&gt; unlock<br></code></pre></td></tr></table></figure><h2 id="第三章：synchronized保证三大特性"><a href="#第三章：synchronized保证三大特性" class="headerlink" title="第三章：synchronized保证三大特性"></a>第三章：synchronized保证三大特性</h2><p>synchronized能够保证在同一时刻最多只有一个线程执行该段代码,以达到保证并发安全的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (锁对象) &#123;<br>    <span class="hljs-comment">// 受保护资源;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="synchronized与原子性"><a href="#synchronized与原子性" class="headerlink" title="synchronized与原子性"></a>synchronized与原子性</h3><hr><h4 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h4><p>学习使用synchronized保证原子性的原理</p><h4 id="使用synchronized保证原子性"><a href="#使用synchronized保证原子性" class="headerlink" title="使用synchronized保证原子性"></a>使用synchronized保证原子性</h4><p>案例演示:5个线程各执行1000次 i++;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo02_concurrent_problem;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * synchronized保证原子性操作</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 原子性（Atomicity）：在一次或多次操作中,要么所有的操作都执行并且不会受其他因素干扰而中</span><br><span class="hljs-comment"> * 断,要么所有的操作都不执行。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02Atomicity</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">increment</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>                    number++;<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        List&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(increment);<br>            t.start();<br>            list.add(t);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(Thread t : list)&#123;<br>            t.join();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;number = &quot;</span> + number);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>        number++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="synchronized保证原子性的原理"><a href="#synchronized保证原子性的原理" class="headerlink" title="synchronized保证原子性的原理"></a>synchronized保证原子性的原理</h4><p>对number++;增加同步代码块后,保证同一时间只有一个线程操作number++;。就不会出现安全问题。</p><h4 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h4><p>synchronized保证原子性的原理,synchronized保证只有一个线程拿到锁,能够进入同步代码块。</p><h3 id="synchronized与可见性"><a href="#synchronized与可见性" class="headerlink" title="synchronized与可见性"></a>synchronized与可见性</h3><hr><h4 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h4><p>学习使用synchronized保证可见性的原理</p><h4 id="使用synchronized保证可见性"><a href="#使用synchronized保证可见性" class="headerlink" title="使用synchronized保证可见性"></a>使用synchronized保证可见性</h4><p>案例演示：一个线程根据boolean类型的标记flag, while循环,另一个线程改变这个flag变量的值,另<br>一个线程并不会停止循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo02_concurrent_problem;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * synchronized保证可见性操作</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 可见性（Visibility）：是指一个线程对共享变量进行修改,另一个线程立即得到修改后的最新值</span><br><span class="hljs-comment"> * 可见性演示</span><br><span class="hljs-comment"> *      一个线程对共享变量的修改,另一个线程不能立即得到最新值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01Visibility</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当写一个volatile变量时,JMM会把该线程本地内存中的变量强制刷新到主内存中去；</span><br><span class="hljs-comment">     *     这个写会操作会导致其他线程中的volatile变量缓存无效</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// private static volatile boolean run = true;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">//线程2修改后线程1并没有结束,程序一直在运行</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run)&#123;<br>                <span class="hljs-keyword">synchronized</span> (Test01Visibility.class)&#123;<br><br>                &#125;<br>                <span class="hljs-comment">// System.out.println(run);</span><br>            &#125;<br>        &#125;);<br><br>        t1.start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            run = <span class="hljs-literal">false</span>;<br>            System.out.println(<span class="hljs-string">&quot;时间到,线程2设置为false&quot;</span>);<br>        &#125;);<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="synchronized保证可见性的原理"><a href="#synchronized保证可见性的原理" class="headerlink" title="synchronized保证可见性的原理"></a>synchronized保证可见性的原理</h4><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/10.png" class=""></div><h4 id="小结-7"><a href="#小结-7" class="headerlink" title="小结"></a>小结</h4><p>synchronized保证可见性的原理,执行synchronized时,会对应lock原子操作会刷新工作内存中共享变<br>量的值</p><h3 id="synchronized与有序性"><a href="#synchronized与有序性" class="headerlink" title="synchronized与有序性"></a>synchronized与有序性</h3><hr><h4 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h4><p>学习使用synchronized保证有序性的原理</p><h4 id="为什么要重排序"><a href="#为什么要重排序" class="headerlink" title="为什么要重排序"></a>为什么要重排序</h4><p>为了提高程序的执行效率,编译器和CPU会对程序中代码进行重排序。</p><h5 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h5><p>as-if-serial语义的意思是：不管编译器和CPU如何重排序,必须保证在单线程情况下程序的结果是正确<br>的。</p><p>以下数据有依赖关系,不能重排序。</p><p>写后读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br></code></pre></td></tr></table></figure><p>写后写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>读后写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>编译器和处理器不会对存在数据依赖关系的操作做重排序,因为这种重排序会改变执行结果。但是,如<br>果操作之间不存在数据依赖关系,这些操作就可能被编译器和处理器重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br></code></pre></td></tr></table></figure><p>如上所示a和c之间存在数据依赖关系,同时b和c之间也存在数据依赖关系。因此在最终执行的指令序<br>列中,c不能被重排序到a和b的前面。但a和b之间没有数据依赖关系,编译器和处理器可以重排序a和b<br>之间的执行顺序。下面是该程序的两种执行顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//可以这样：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br><br><span class="hljs-comment">//也可以重排序这样：</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br></code></pre></td></tr></table></figure><h4 id="使用synchronized保证有序性"><a href="#使用synchronized保证有序性" class="headerlink" title="使用synchronized保证有序性"></a>使用synchronized保证有序性</h4><p>Test03Orderliness.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo02_concurrent_problem;<br><br><span class="hljs-keyword">import</span> org.openjdk.jcstress.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * synchronized保证有序性操作</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 有序性</span><br><span class="hljs-comment"> * 是指程序中代码的执行顺序,Java在编译时和运行时会对代码进行优化,会导致</span><br><span class="hljs-comment"> * 程序最终的执行顺序不一定就是我们编写代码时的顺序。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 出现0的结果就是线程2执行顺序出现问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@JCStressTest</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;1&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok1&quot;)</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;4&quot;&#125;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger1&quot;)</span><br><span class="hljs-meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;danger2&quot;)</span><br><span class="hljs-meta">@State</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03Orderliness</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-comment">//线程1</span><br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>            <span class="hljs-keyword">if</span>(ready)&#123;<br>                r.r1 = num + num;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r.r1 = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//线程2</span><br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>            num = <span class="hljs-number">2</span>;<br>            ready = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="synchronized保证有序性的原理"><a href="#synchronized保证有序性的原理" class="headerlink" title="synchronized保证有序性的原理"></a>synchronized保证有序性的原理</h4><p>synchronized后,虽然进行了重排序,保证只有一个线程会进入同步代码块,也能保证有序性。</p><h4 id="小结-8"><a href="#小结-8" class="headerlink" title="小结"></a>小结</h4><p>synchronized保证有序性的原理,我们加synchronized后,依然会发生重排序,只不过,我们有同步<br>代码块,可以保证只有一个线程执行同步代码中的代码。保证有序性</p><h2 id="第四章：synchronized的特性"><a href="#第四章：synchronized的特性" class="headerlink" title="第四章：synchronized的特性"></a>第四章：synchronized的特性</h2><h3 id="可重入特性"><a href="#可重入特性" class="headerlink" title="可重入特性"></a>可重入特性</h3><hr><h4 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h4><p>了解什么是可重入</p><p>了解可重入的原理</p><h4 id="什么是可重入"><a href="#什么是可重入" class="headerlink" title="什么是可重入"></a>什么是可重入</h4><p>一个线程可以多次执行synchronized,重复获取同一把锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo03_concurrent_problem;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>().start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>().start();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (MyThread.class)&#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>            System.out.println(name + <span class="hljs-string">&quot;进入了同步代码快2&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (MyThread.class)&#123;<br>            System.out.println(getName() + <span class="hljs-string">&quot;进入了同步代码快1&quot;</span>);<br><br>            <span class="hljs-comment">// synchronized (MyThread.class)&#123;</span><br>            <span class="hljs-comment">//     System.out.println(getName() + &quot;进入了同步代码快2&quot;);</span><br>            <span class="hljs-comment">// &#125;</span><br>            Demo01.test01();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h4><p>synchronized的锁对象中有一个计数器（recursions变量）会记录线程获得几次锁.</p><h4 id="可重入的好处"><a href="#可重入的好处" class="headerlink" title="可重入的好处"></a>可重入的好处</h4><ol><li>可以避免死锁</li><li>可以让我们更好的来封装代码</li></ol><h4 id="小结-9"><a href="#小结-9" class="headerlink" title="小结"></a>小结</h4><p>synchronized是可重入锁,内部锁对象中会有一个计数器记录线程获取几次锁啦,在执行完同步代码块<br>时,计数器的数量会-1,知道计数器的数量为0,就释放这个锁。</p><h3 id="不可中断特性"><a href="#不可中断特性" class="headerlink" title="不可中断特性"></a>不可中断特性</h3><hr><h4 id="目标-10"><a href="#目标-10" class="headerlink" title="目标"></a>目标</h4><p>学习synchronized不可中断特性</p><p>学习Lock的可中断特性</p><h4 id="什么是不可中断"><a href="#什么是不可中断" class="headerlink" title="什么是不可中断"></a>什么是不可中断</h4><p>一个线程获得锁后,另一个线程想要获得锁,必须处于阻塞或等待状态,如果第一个线程不释放锁,第<br>二个线程会一直阻塞或等待,不可被中断。</p><h4 id="synchronized不可中断演示"><a href="#synchronized不可中断演示" class="headerlink" title="synchronized不可中断演示"></a>synchronized不可中断演示</h4><p>synchronized是不可中断,处于阻塞状态的线程会一直等待锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo03_concurrent_problem;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 目标:演示synchronized不可中断</span><br><span class="hljs-comment"> *      1.定义一个Runnable</span><br><span class="hljs-comment"> *      2.在Runnable定义同步代码块</span><br><span class="hljs-comment"> *      3.先开启一个线程来执行同步代码块,保证不退出同步代码块</span><br><span class="hljs-comment"> *      4.后开启一个线程来执行同步代码块(阻塞状态)</span><br><span class="hljs-comment"> *      5.停止第二个线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02_Uninterruptible</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 1.定义一个Runnable</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-comment">// 2.在Runnable定义同步代码块</span><br>            <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>                System.out.println(name + <span class="hljs-string">&quot;进入同步代码块&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">8888888</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 3.先开启一个线程来执行同步代码块,保证不退出同步代码块</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(run);<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">// 4.后开启一个线程来执行同步代码块(阻塞状态)</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(run);<br>        t2.start();<br>        <span class="hljs-comment">// 5.停止第二个线程</span><br>        System.out.println(<span class="hljs-string">&quot;停止线程前&quot;</span>);<br>        t2.interrupt();<br>        System.out.println(<span class="hljs-string">&quot;停止线程后&quot;</span>);<br><br>        System.out.println(t1.getState());<br>        System.out.println(t2.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ReentrantLock可中断演示"><a href="#ReentrantLock可中断演示" class="headerlink" title="ReentrantLock可中断演示"></a>ReentrantLock可中断演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo03_concurrent_problem;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ReentrantLock可中断演示</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03_Interruptible</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        test02();<br>    &#125;<br><br>    <span class="hljs-comment">// 演示Lock不可中断</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lock();<br>                System.out.println(name + <span class="hljs-string">&quot;获得锁,进入锁执行&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">88888</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>                System.out.println(name + <span class="hljs-string">&quot;释放锁&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(run);<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(run);<br>        t2.start();<br><br>        System.out.println(<span class="hljs-string">&quot;停止t2线程前&quot;</span>);<br>        t2.interrupt();<br>        System.out.println(<span class="hljs-string">&quot;停止t2线程后&quot;</span>);<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        System.out.println(t1.getState());<br>        System.out.println(t2.getState());<br>    &#125;<br><br>    <span class="hljs-comment">//演示Lock可中断</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                b = lock.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>                <span class="hljs-keyword">if</span>(b) &#123;<br>                    System.out.println(name + <span class="hljs-string">&quot;获得锁,进入锁执行&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">88888</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    System.out.println(name + <span class="hljs-string">&quot;在指定时间没有得到锁做其他操作&quot;</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span>(b)&#123;<br>                    lock.unlock();<br>                    System.out.println(name + <span class="hljs-string">&quot;释放锁&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(run);<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(run);<br>        t2.start();<br><br>        <span class="hljs-comment">// System.out.println(&quot;停止t2线程前&quot;);</span><br>        <span class="hljs-comment">// t2.interrupt();</span><br>        <span class="hljs-comment">// System.out.println(&quot;停止t2线程后&quot;);</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">//</span><br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        System.out.println(t1.getState());<br>        System.out.println(t2.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-10"><a href="#小结-10" class="headerlink" title="小结"></a>小结</h4><p>不可中断是指,当一个线程获得锁后,另一个线程一直处于阻塞或等待状态,前一个线程不释放锁,后<br>一个线程会一直阻塞或等待,不可被中断。</p><p>synchronized属于不可被中断</p><p>Lock的lock方法是不可中断的</p><p>Lock的tryLock方法是可中断的</p><h2 id="第五章：synchronized原理"><a href="#第五章：synchronized原理" class="headerlink" title="第五章：synchronized原理"></a>第五章：synchronized原理</h2><h3 id="javap-反汇编"><a href="#javap-反汇编" class="headerlink" title="javap 反汇编"></a>javap 反汇编</h3><hr><h4 id="目标-11"><a href="#目标-11" class="headerlink" title="目标"></a>目标</h4><p>通过javap反汇编学习synchronized的原理</p><p>我们编写一个简单的synchronized代码,如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo04_concurrent_problem;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们要看synchronized的原理,但是synchronized是一个关键字,看不到源码。我们可以将class文件<br>进行反汇编。</p><p>JDK自带的一个工具： javap ,对字节码进行反汇编,查看字节码指令。</p><p>在DOS命令行输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">javap -p -v -c .\target\classes\com\huajframe\demo04_concurrent_problem\Demo01.class<br></code></pre></td></tr></table></figure><p>反汇编后的效果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs text">public static void main(java.lang.String[]);<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=2, locals=3, args_size=1<br>         0: getstatic     #2                  // Field obj:Ljava/lang/Object;<br>         3: dup<br>         4: astore_1<br>         5: monitorenter<br>         6: getstatic     #3                  // Field java/lang/System.out:Ljava/io/Print<br>Stream;<br>         9: ldc           #4                  // String 1<br>        11: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava<br>/lang/String;)V<br>        14: aload_1<br>        15: monitorexit<br>        16: goto          24<br>        19: astore_2<br>        20: aload_1<br>        21: monitorexit<br>        22: aload_2<br>        23: athrow<br>        24: return<br>      Exception table:<br>         from    to  target type<br>             6    16    19   any<br>            19    22    19   any<br>      LineNumberTable:<br>        line 6: 0<br>        line 7: 6<br>        line 8: 14<br>        line 9: 24<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0      25     0  args   [Ljava/lang/String;<br>      StackMapTable: number_of_entries = 2<br>        frame_type = 255 /* full_frame */<br>          offset_delta = 19<br>          locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ]<br>          stack = [ class java/lang/Throwable ]<br>        frame_type = 250 /* chop */<br>          offset_delta = 4<br><br>  public synchronized void test();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC, ACC_SYNCHRONIZED<br>    Code:<br>      stack=2, locals=1, args_size=1<br>         0: getstatic     #3                  // Field java/lang/System.out:Ljava/io/Print<br>Stream;<br>         3: ldc           #6                  // String a<br>         5: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava<br>/lang/String;)V<br>         8: return<br>      LineNumberTable:<br>        line 12: 0<br>        line 13: 8<br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            0       9     0  this   Lcom/huajframe/demo04_concurrent_problem/Demo01;<br></code></pre></td></tr></table></figure><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/11.png" class=""></div><h4 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h4><p><strong>首先我们来看一下JVM规范中对于monitorenter的描述：</strong></p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter</a></p><blockquote><p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner.<br>The thread that executes monitorenter attempts to gain ownership of the monitor<br>associated with objectref, as follows: • If the entry count of the monitor associated with<br>objectref is zero, the thread enters the monitor and sets its entry count to one. The thread<br>is then the owner of the monitor. • If the thread already owns the monitor associated with<br>objectref, it reenters the monitor, incrementing its entry count. • If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s<br>entry count is zero, then tries again to gain ownership.</p></blockquote><p>翻译过来： 每一个对象都会和一个监视器monitor关联。监视器被占用时会被锁住,其他线程无法来获<br>取该monitor。 当JVM执行某个线程的某个方法内部的monitorenter时,它会尝试去获取当前对象对应<br>的monitor的所有权。其过程如下：</p><ol><li>若monior的进入数为0,线程可以进入monitor,并将monitor的进入数置为1。当前线程成为<br>monitor的owner（所有者）</li><li>若线程已拥有monitor的所有权,允许它重入monitor,则进入monitor的进入数加1</li><li>若其他线程已经占有monitor的所有权,那么当前尝试获取monitor的所有权的线程会被阻塞,直<br>到monitor的进入数变为0,才能重新尝试获取monitor的所有权。</li></ol><p>monitorenter小结:</p><p>synchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的,是JVM的线程执行到这个<br>同步代码块,发现锁对象没有monitor就会创建monitor,monitor内部有两个重要的成员变量owner:拥有<br>这把锁的线程,recursions会记录线程拥有锁的次数,当一个线程拥有monitor后其他线程只能等待</p><h4 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h4><p><strong>首先我们来看一下JVM规范中对于monitorexit的描述：</strong><br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit</a></p><blockquote><p>The thread that executes monitorexit must be the owner of the monitor associated with the<br>instance referenced by objectref. The thread decrements the entry count of the monitor<br>associated with objectref. If as a result the value of the entry count is zero, the thread<br>exits the monitor and is no longer its owner. Other threads that are blocking to enter the<br>monitor are allowed to attempt to do so.</p></blockquote><p>翻译过来：</p><ol><li>能执行monitorexit指令的线程一定是拥有当前对象的monitor的所有权的线程。</li><li>执行monitorexit时会将monitor的进入数减1。当monitor的进入数减为0时,当前线程退出<br>monitor,不再拥有monitor的所有权,此时其他被这个monitor阻塞的线程可以尝试去获取这个<br>monitor的所有权</li></ol><p>monitorexit释放锁。</p><p>monitorexit插入在方法结束处和异常处,JVM保证每个monitorenter必须有对应的monitorexit。</p><blockquote><p>面试题synchroznied出现异常会释放锁吗?</p><p>会释放锁</p></blockquote><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10</a></p><p>可以看到同步方法在反汇编后,会增加ACC_SYNCHRONIZED 修饰。会隐式调用monitorenter和<br>monitorexit。在执行同步方法前会调用monitorenter,在执行完同步方法后会调用monitorexit。</p><h4 id="小结-11"><a href="#小结-11" class="headerlink" title="小结"></a>小结</h4><p>通过javap反汇编我们看到synchronized使用编程了monitorentor和monitorexit两个指令.每个锁对象<br>都会关联一个monitor(监视器,它才是真正的锁对象),它内部有两个重要的成员变量owner会保存获得锁<br>的线程,recursions会保存线程获得锁的次数,当执行到monitorexit时,recursions会-1,当计数器减到0时<br>这个线程就会释放锁</p><h4 id="面试题：synchronized与Lock的区别"><a href="#面试题：synchronized与Lock的区别" class="headerlink" title="面试题：synchronized与Lock的区别"></a>面试题：synchronized与Lock的区别</h4><ol><li>synchronized是关键字,而Lock是一个接口。</li><li>synchronized会自动释放锁,而Lock必须手动释放锁。</li><li>synchronized是不可中断的,Lock可以中断也可以不中断。</li><li>通过Lock可以知道线程有没有拿到锁,而synchronized不能。</li><li>synchronized能锁住方法和代码块,而Lock只能锁住代码块。</li><li>Lock可以使用读锁提高多线程读效率。</li><li>synchronized是非公平锁,ReentrantLock可以控制是否是公平锁。</li></ol><h3 id="深入JVM源码"><a href="#深入JVM源码" class="headerlink" title="深入JVM源码"></a>深入JVM源码</h3><hr><h4 id="目标-12"><a href="#目标-12" class="headerlink" title="目标"></a>目标</h4><p>通过JVM源码分析synchronized的原理</p><h4 id="JVM源码下载"><a href="#JVM源码下载" class="headerlink" title="JVM源码下载"></a>JVM源码下载</h4><p><a href="http://openjdk.java.net/">http://openjdk.java.net/</a>    –&gt; Mercurial –&gt; jdk8 –&gt; hotspot –&gt; zip</p><h4 id="IDE-Clion-下载"><a href="#IDE-Clion-下载" class="headerlink" title="IDE(Clion )下载"></a>IDE(Clion )下载</h4><p><a href="https://www.jetbrains.com/">https://www.jetbrains.com/</a></p><h4 id="monitor监视器锁"><a href="#monitor监视器锁" class="headerlink" title="monitor监视器锁"></a>monitor监视器锁</h4><p>可以看出无论是synchronized代码块还是synchronized方法,其线程安全的语义实现最终依赖一个叫<br>monitor的东西,那么这个神秘的东西是什么呢？下面让我们来详细介绍一下。</p><p>在HotSpot虚拟机中,monitor是由ObjectMonitor实现的。其源码是用c++来实现的,位于HotSpot虚<br>拟机源码ObjectMonitor.hpp文件中(src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.hpp)。ObjectMonitor主<br>要数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ObjectMonitor</span>() &#123;<br>    _header = <span class="hljs-literal">NULL</span>;<br>    _count = <span class="hljs-number">0</span>;<br>    _waiters = <span class="hljs-number">0</span>,<br>    _recursions = <span class="hljs-number">0</span>; <span class="hljs-comment">// 线程的重入次数</span><br>    _object = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 存储该monitor的对象</span><br>    _owner = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 标识拥有该monitor的线程</span><br>    _WaitSet = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 处于wait状态的线程,会被加入到_WaitSet</span><br>    _WaitSetLock = <span class="hljs-number">0</span> ;<br>    _Responsible = <span class="hljs-literal">NULL</span>;<br>    _succ = <span class="hljs-literal">NULL</span>;<br>    _cxq = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 多线程竞争锁时的单向列表</span><br>    FreeNext = <span class="hljs-literal">NULL</span>;<br>    _EntryList = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 处于等待锁block状态的线程,会被加入到该列表</span><br>    _SpinFreq = <span class="hljs-number">0</span>;<br>    _SpinClock = <span class="hljs-number">0</span>;<br>    OwnerIsThread = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>_owner：初始时为NULL。当有线程占有该monitor时,owner标记为该线程的唯一标识。当线程<br>释放monitor时,owner又恢复为NULL。owner是一个临界资源,JVM是通过CAS操作来保证其线<br>程安全的。</li><li>_cxq：竞争队列,所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资<br>源,JVM通过CAS原子指令来修改_cxq队列。修改前_cxq的旧值填入了node的next字段,_cxq指<br>向新值（新线程）。因此_cxq是一个后进先出的stack（栈）。</li><li>_EntryList：_cxq队列中有资格成为候选资源的线程会被移动到该队列中。</li><li>_WaitSet：因为调用wait方法而被阻塞的线程会被放在该队列中。</li></ol><p>每一个Java对象都可以与一个监视器monitor关联,我们可以把它理解成为一把锁,当一个线程想要执<br>行一段被synchronized圈起来的同步方法或者代码块时,该线程得先获取到synchronized修饰的对象<br>对应的monitor。</p><p>我们的Java代码里不会显示地去创造这么一个monitor对象,我们也无需创建,事实上可以这么理解：<br>monitor并不是随着对象创建而创建的。我们是通过synchronized修饰符告诉JVM需要为我们的某个对<br>象创建关联的monitor对象。每个线程都存在两个ObjectMonitor对象列表,分别为free和used列表。<br>同时JVM中也维护着global locklist。当线程需要ObjectMonitor对象时,首先从线程自身的free表中申<br>请,若存在则使用,若不存在则从global list中申请。</p><p>ObjectMonitor的数据结构中包含：_owner、_WaitSet和_EntryList,它们之间的关系转换可以用下图<br>表示：</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/12.png" class=""></div><h4 id="monitor竞争"><a href="#monitor竞争" class="headerlink" title="monitor竞争"></a>monitor竞争</h4><ol><li><p>执行monitorenter时,会调用InterpreterRuntime.cpp </p><p> (位于：src&#x2F;share&#x2F;vm&#x2F;interpreter&#x2F;interpreterRuntime.cpp) 的 InterpreterRuntime::monitorenter函<br>数。具体代码可参见HotSpot源码。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="hljs-type">void</span>, InterpreterRuntime::<span class="hljs-built_in">monitorenter</span>(JavaThread* thread,<br>BasicObjectLock* elem))<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ASSERT</span><br>    thread-&gt;<span class="hljs-built_in">last_frame</span>().<span class="hljs-built_in">interpreter_frame_verify_monitor</span>(elem);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span> (PrintBiasedLockingStatistics) &#123;<br>        Atomic::<span class="hljs-built_in">inc</span>(BiasedLocking::<span class="hljs-built_in">slow_path_entry_count_addr</span>());<br>    &#125;<br>    <span class="hljs-function">Handle <span class="hljs-title">h_obj</span><span class="hljs-params">(thread, elem-&gt;obj())</span></span>;<br>    <span class="hljs-built_in">assert</span>(Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">is_in_reserved_or_null</span>(<span class="hljs-built_in">h_obj</span>()),<br>            <span class="hljs-string">&quot;must be NULL or an object&quot;</span>);<br>    <span class="hljs-keyword">if</span> (UseBiasedLocking) &#123;<br>        <span class="hljs-comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span><br>        ObjectSynchronizer::<span class="hljs-built_in">fast_enter</span>(h_obj, elem-&gt;<span class="hljs-built_in">lock</span>(), <span class="hljs-literal">true</span>, CHECK);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ObjectSynchronizer::<span class="hljs-built_in">slow_enter</span>(h_obj, elem-&gt;<span class="hljs-built_in">lock</span>(), CHECK);<br>    &#125;<br>    <span class="hljs-built_in">assert</span>(Universe::<span class="hljs-built_in">heap</span>()-&gt;<span class="hljs-built_in">is_in_reserved_or_null</span>(elem-&gt;<span class="hljs-built_in">obj</span>()),<br>            <span class="hljs-string">&quot;must be NULL or an object&quot;</span>); <br></code></pre></td></tr></table></figure><ol start="2"><li>对于重量级锁,monitorenter函数中会调用 ObjectSynchronizer::slow_enter</li><li>最终调用 ObjectMonitor::enter（位于：src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp）,源码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> ATTR <span class="hljs-title">ObjectMonitor::enter</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">// The following code is ordered to check the most common cases first</span><br>    <span class="hljs-comment">// and to reduce RTS-&gt;RTO cache line upgrades on SPARC and IA32 processors.</span><br>    Thread * <span class="hljs-type">const</span> Self = THREAD ;<br>    <span class="hljs-type">void</span> * cur ;<br>    <br>    <span class="hljs-comment">// 通过CAS操作尝试把monitor的_owner字段设置为当前线程</span><br>    cur = Atomic::<span class="hljs-built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="hljs-literal">NULL</span>) ;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// Either ASSERT _recursions == 0 or explicitly set _recursions = 0.</span><br>        <span class="hljs-built_in">assert</span> (_recursions == <span class="hljs-number">0</span> , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-built_in">assert</span> (_owner == Self, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-comment">// CONSIDER: set or assert OwnerIsThread == 1</span><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">// 线程重入,recursions++</span><br>    <span class="hljs-keyword">if</span> (cur == Self) &#123;<br>        <span class="hljs-comment">// TODO-<span class="hljs-doctag">FIXME:</span> check for integer overflow! BUGID 6557169.</span><br>        _recursions ++ ;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">// 如果当前线程是第一次进入该monitor,设置_recursions为1,_owner为当前线程</span><br>    <span class="hljs-keyword">if</span> (Self-&gt;<span class="hljs-built_in">is_lock_owned</span> ((address)cur)) &#123;<br>        <span class="hljs-built_in">assert</span> (_recursions == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;internal state error&quot;</span>);<br>        _recursions = <span class="hljs-number">1</span> ;<br>        <span class="hljs-comment">// Commute owner from a thread-specific on-stack BasicLockObject address to</span><br>        <span class="hljs-comment">// a full-fledged &quot;Thread *&quot;.</span><br>        _owner = Self ;<br>        OwnerIsThread = <span class="hljs-number">1</span> ;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">// 省略一些代码</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        jt-&gt;<span class="hljs-built_in">set_suspend_equivalent</span>();<br>        <span class="hljs-comment">// cleared by handle_special_suspend_equivalent_condition()</span><br>        <span class="hljs-comment">// or java_suspend_self()</span><br>        <span class="hljs-comment">// 如果获取锁失败,则等待锁的释放；</span><br>        <span class="hljs-built_in">EnterI</span> (THREAD) ;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ExitSuspendEquivalent</span>(jt)) <span class="hljs-keyword">break</span> ;<br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// We have acquired the contended monitor, but while we were</span><br>        <span class="hljs-comment">// waiting another thread suspended us. We don&#x27;t want to enter</span><br>        <span class="hljs-comment">// the monitor while suspended because that would surprise the</span><br>        <span class="hljs-comment">// thread that suspended us.</span><br>        <span class="hljs-comment">//</span><br>            _recursions = <span class="hljs-number">0</span> ;<br>        _succ = <span class="hljs-literal">NULL</span> ;<br>        <span class="hljs-built_in">exit</span> (<span class="hljs-literal">false</span>, Self) ;<br>        jt-&gt;<span class="hljs-built_in">java_suspend_self</span>();<br>    &#125;<br>    Self-&gt;<span class="hljs-built_in">set_current_pending_monitor</span>(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>此处省略锁的自旋优化等操作,统一放在后面synchronzied优化中说。</p><p>以上代码的具体流程概括如下：</p><ol><li>通过CAS尝试把monitor的owner字段设置为当前线程。</li><li>如果设置之前的owner指向当前线程,说明当前线程再次进入monitor,即重入锁,执行<br>recursions ++ ,记录重入的次数。</li><li>如果当前线程是第一次进入该monitor,设置recursions为1,_owner为当前线程,该线程成功获<br>得锁并返回。</li><li>如果获取锁失败,则等待锁的释放。</li></ol><h4 id="monitor等待"><a href="#monitor等待" class="headerlink" title="monitor等待"></a>monitor等待</h4><p>竞争失败等待调用的是ObjectMonitor对象的EnterI方法（位于：src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp）,源码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> ATTR <span class="hljs-title">ObjectMonitor::EnterI</span> <span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    Thread * Self = THREAD ;<br>    <span class="hljs-comment">// Try the lock - TATAS</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span> (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">assert</span> (_succ != Self , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-built_in">assert</span> (_owner == Self , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-built_in">assert</span> (_Responsible != Self , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TrySpin</span> (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">assert</span> (_owner == Self , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-built_in">assert</span> (_succ != Self , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-built_in">assert</span> (_Responsible != Self , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">// 省略部分代码</span><br>        <br>    <span class="hljs-comment">// 当前线程被封装成ObjectWaiter对象node,状态设置成ObjectWaiter::TS_CXQ；</span><br>    <span class="hljs-function">ObjectWaiter <span class="hljs-title">node</span><span class="hljs-params">(Self)</span> </span>;<br>    Self-&gt;_ParkEvent-&gt;<span class="hljs-built_in">reset</span>() ;<br>    node._prev = (ObjectWaiter *) <span class="hljs-number">0xBAD</span> ;<br>    node.TState = ObjectWaiter::TS_CXQ ;<br>    <br>    <span class="hljs-comment">// 通过CAS把node节点push到_cxq列表中</span><br>    ObjectWaiter * nxt ;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        node._next = nxt = _cxq ;<br>        <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg_ptr</span> (&amp;node, &amp;_cxq, nxt) == nxt) <span class="hljs-keyword">break</span> ;<br>        <span class="hljs-comment">// Interference - the CAS failed because _cxq changed. Just retry.</span><br>        <span class="hljs-comment">// As an optional optimization we retry the lock.</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span> (Self) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">assert</span> (_succ != Self , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            <span class="hljs-built_in">assert</span> (_owner == Self , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            <span class="hljs-built_in">assert</span> (_Responsible != Self , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 省略部分代码</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 线程在被挂起前做一下挣扎,看能不能获取到锁</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span> (Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br>            <span class="hljs-built_in">assert</span> (_owner != Self, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            <span class="hljs-keyword">if</span> ((SyncFlags &amp; <span class="hljs-number">2</span>) &amp;&amp; _Responsible == <span class="hljs-literal">NULL</span>) &#123;<br>            Atomic::<span class="hljs-built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="hljs-literal">NULL</span>) ;<br>        &#125;<br>        <span class="hljs-comment">// park self</span><br>        <span class="hljs-keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-built_in">TEVENT</span> (Inflated enter - park TIMED) ;<br>            Self-&gt;_ParkEvent-&gt;<span class="hljs-built_in">park</span> ((jlong) RecheckInterval) ;<br>            <span class="hljs-comment">// Increase the RecheckInterval, but clamp the value.</span><br>            RecheckInterval *= <span class="hljs-number">8</span> ;<br>        <span class="hljs-keyword">if</span> (RecheckInterval &gt; <span class="hljs-number">1000</span>) RecheckInterval = <span class="hljs-number">1000</span> ;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">TEVENT</span> (Inflated enter - park UNTIMED) ;<br>            <span class="hljs-comment">// 通过park将当前线程挂起,等待被唤醒</span><br>            Self-&gt;_ParkEvent-&gt;<span class="hljs-built_in">park</span>() ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span>(Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br>        <span class="hljs-comment">// 省略部分代码</span><br>    &#125;<br>    <span class="hljs-comment">// 省略部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当该线程被唤醒时,会从挂起的点继续执行,通过ObjectMonitor::TryLock 尝试获取锁,TryLock方<br>法实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ObjectMonitor::TryLock</span> <span class="hljs-params">(Thread * Self)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">void</span> * own = _owner ;<br>        <span class="hljs-keyword">if</span> (own != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="hljs-literal">NULL</span>) == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// Either guarantee _recursions == 0 or set _recursions = 0.</span><br>            <span class="hljs-built_in">assert</span> (_recursions == <span class="hljs-number">0</span>, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            <span class="hljs-built_in">assert</span> (_owner == Self, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            <span class="hljs-comment">// CONSIDER: set or assert that OwnerIsThread == 1</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> ;<br>        &#125;<br>        <span class="hljs-comment">// The lock had been free momentarily, but we lost the race to the lock.</span><br>        <span class="hljs-comment">// Interference -- the CAS failed.</span><br>        <span class="hljs-comment">// We can either return -1 or retry.</span><br>        <span class="hljs-comment">// Retry doesn&#x27;t make as much sense because the lock was just acquired.</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span> ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码的具体流程概括如下：</p><ol><li>当前线程被封装成ObjectWaiter对象node,状态设置成ObjectWaiter::TS_CXQ。</li><li>在for循环中,通过CAS把node节点push到_cxq列表中,同一时刻可能有多个线程把自己的node<br>节点push到_cxq列表中。</li><li>node节点push到_cxq列表之后,通过自旋尝试获取锁,如果还是没有获取到锁,则通过park将当<br>前线程挂起,等待被唤醒。</li><li>当该线程被唤醒时,会从挂起的点继续执行,通过ObjectMonitor::TryLock 尝试获取锁。</li></ol><h4 id="monitor释放"><a href="#monitor释放" class="headerlink" title="monitor释放"></a>monitor释放</h4><p>当某个持有锁的线程执行完同步代码块时,会进行锁的释放,给其它线程机会执行同步代码,在<br>HotSpot中,通过退出monitor的方式实现锁的释放,并通知被阻塞的线程,具体实现位于<br>ObjectMonitor的exit方法中。（位于：src&#x2F;share&#x2F;vm&#x2F;runtime&#x2F;objectMonitor.cpp）,源码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> ATTR <span class="hljs-title">ObjectMonitor::exit</span><span class="hljs-params">(<span class="hljs-type">bool</span> not_suspended, TRAPS)</span> </span>&#123;<br>    Thread * Self = THREAD ;<br>    <span class="hljs-comment">// 省略部分代码</span><br>    <span class="hljs-keyword">if</span> (_recursions != <span class="hljs-number">0</span>) &#123;<br>        _recursions--;   <span class="hljs-comment">// this is simple recursive enter</span><br>        <span class="hljs-built_in">TEVENT</span> (Inflated exit - recursive) ;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br><br>    <span class="hljs-comment">// 省略部分代码</span><br>    ObjectWaiter * w = <span class="hljs-literal">NULL</span> ;<br>    <span class="hljs-type">int</span> QMode = Knob_QMode ;<br>    <span class="hljs-comment">// qmode = 2：直接绕过EntryList队列,从cxq队列中获取线程用于竞争锁</span><br>    <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">2</span> &amp;&amp; _cxq != <span class="hljs-literal">NULL</span>) &#123;<br>        w = _cxq ;<br>        <span class="hljs-built_in">assert</span> (w != <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>        <span class="hljs-built_in">ExitEpilog</span> (Self, w) ;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    <span class="hljs-comment">// qmode =3：cxq队列插入EntryList尾部；</span><br>    <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">3</span> &amp;&amp; _cxq != <span class="hljs-literal">NULL</span>) &#123;<br>        w = _cxq ;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-built_in">assert</span> (w != <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>            ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="hljs-built_in">cmpxchg_ptr</span> (<span class="hljs-literal">NULL</span>,&amp;_cxq, w) ;<br>                <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>                w = u ;<br>        &#125;<br>        <span class="hljs-built_in">assert</span> (w != <span class="hljs-literal">NULL</span> , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        ObjectWaiter * q = <span class="hljs-literal">NULL</span> ;<br>        ObjectWaiter * p ;<br>        <span class="hljs-keyword">for</span> (p = w ; p != <span class="hljs-literal">NULL</span> ; p = p-&gt;_next) &#123;<br>            <span class="hljs-built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>            p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>            p-&gt;_prev = q ;<br>            q = p ;<br>        &#125;<br>        ObjectWaiter * Tail ;<br>        <span class="hljs-keyword">for</span> (Tail = _EntryList ; Tail != <span class="hljs-literal">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="hljs-literal">NULL</span> ; Tail = Tail-&gt;_next) ;<br>        <span class="hljs-keyword">if</span> (Tail == <span class="hljs-literal">NULL</span>) &#123;<br>            _EntryList = w ;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Tail-&gt;_next = w ;<br>            w-&gt;_prev = Tail ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// qmode =4：cxq队列插入到_EntryList头部</span><br>    <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">4</span> &amp;&amp; _cxq != <span class="hljs-literal">NULL</span>) &#123;<br>        w = _cxq ;<br>        <span class="hljs-keyword">for</span> (;;)&#123;<br>            <span class="hljs-built_in">assert</span>(w!=<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Invariant&quot;</span>);<br>            ObjectWaiter*u=(ObjectWaiter*)Atomic::<span class="hljs-built_in">cmpxchg_ptr</span>(<span class="hljs-literal">NULL</span>,<br>            &amp;_cxq, w);<br>            <span class="hljs-keyword">if</span>(u==w)<span class="hljs-keyword">break</span>;<br>            w=u;<br>        &#125;<br><br>        <span class="hljs-built_in">assert</span> (w != <span class="hljs-literal">NULL</span> , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        ObjectWaiter * q = <span class="hljs-literal">NULL</span> ;<br>        ObjectWaiter * p ;<br>        <span class="hljs-keyword">for</span> (p = w ; p != <span class="hljs-literal">NULL</span> ; p = p-&gt;_next) &#123;<br>            <span class="hljs-built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>            p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>            p-&gt;_prev = q ;<br>            q = p ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (_EntryList != <span class="hljs-literal">NULL</span>) &#123;<br>            q-&gt;_next = _EntryList ;<br>            _EntryList-&gt;_prev = q ;<br>        &#125;<br>        _EntryList = w ;<br>    &#125;<br><br>    w = _EntryList ;<br>    <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-built_in">ExitEpilog</span> (Self, w) ;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    w = _cxq ;<br>    <span class="hljs-keyword">if</span> (w == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span> ;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-built_in">assert</span> (w != <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>        ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="hljs-built_in">cmpxchg_ptr</span> (<span class="hljs-literal">NULL</span>, &amp;_cxq,w) ;<br>        <span class="hljs-keyword">if</span> (u == w) <span class="hljs-keyword">break</span> ;<br>        w = u ;<br>    &#125;<br>    <span class="hljs-built_in">TEVENT</span> (Inflated exit - drain cxq into EntryList) ;<br>    <span class="hljs-built_in">assert</span> (w != <span class="hljs-literal">NULL</span> , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>    <span class="hljs-built_in">assert</span> (_EntryList == <span class="hljs-literal">NULL</span> , <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>    <span class="hljs-keyword">if</span> (QMode == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// QMode == 1 : drain cxq to EntryList, reversing order</span><br>        <span class="hljs-comment">// We also reverse the order of the list.</span><br>        ObjectWaiter * s = <span class="hljs-literal">NULL</span> ;<br>        ObjectWaiter * t = w ;<br>        ObjectWaiter * u = <span class="hljs-literal">NULL</span> ;<br>        <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">guarantee</span> (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>            t-&gt;TState = ObjectWaiter::TS_ENTER ;<br>            u = t-&gt;_next ;<br>            t-&gt;_prev = u ;<br>            t-&gt;_next = s ;<br>            s = t;<br>            t = u ;<br>        &#125;<br>        _EntryList = s ;<br>        <span class="hljs-built_in">assert</span> (s != <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;invariant&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// QMode == 0 or QMode == 2</span><br>        _EntryList = w ;<br>        ObjectWaiter * q = <span class="hljs-literal">NULL</span> ;<br>        ObjectWaiter * p ;<br>        <span class="hljs-keyword">for</span> (p = w ; p != <span class="hljs-literal">NULL</span> ; p = p-&gt;_next) &#123;<br>            <span class="hljs-built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="hljs-string">&quot;Invariant&quot;</span>) ;<br>            p-&gt;TState = ObjectWaiter::TS_ENTER ;<br>            p-&gt;_prev = q ;<br>            q = p ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (_succ != <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>;<br>    w = _EntryList ;<br>    <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">guarantee</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>        <span class="hljs-built_in">ExitEpilog</span> (Self, w) ;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>退出同步代码块时会让_recursions减1，当_recursions的值减为0时，说明线程释放了锁。</li><li>根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过<br>ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作最终由unpark完成，实现<br>如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectMonitor::ExitEpilog</span> <span class="hljs-params">(Thread * Self， ObjectWaiter * Wakee)</span> </span>&#123;<br>    <span class="hljs-built_in">assert</span> (_owner == Self， <span class="hljs-string">&quot;invariant&quot;</span>) ;<br>    _succ = Knob_SuccEnabled ? Wakee-&gt;_thread : <span class="hljs-literal">NULL</span> ;<br>    ParkEvent * Trigger = Wakee-&gt;_event ;<br>    Wakee = <span class="hljs-literal">NULL</span> ;<br>    <span class="hljs-comment">// Drop the lock</span><br>    OrderAccess::<span class="hljs-built_in">release_store_ptr</span> (&amp;_owner， <span class="hljs-literal">NULL</span>) ;<br>    OrderAccess::<span class="hljs-built_in">fence</span>() ; <span class="hljs-comment">// ST _owner vs LD in</span><br>    <span class="hljs-built_in">unpark</span>()<br>    <span class="hljs-keyword">if</span> (SafepointSynchronize::<span class="hljs-built_in">do_call_back</span>()) &#123;<br>        <span class="hljs-built_in">TEVENT</span> (unpark before SAFEPOINT) ;<br>    &#125;<br>    <span class="hljs-built_in">DTRACE_MONITOR_PROBE</span>(contended__exit， <span class="hljs-keyword">this</span>， <span class="hljs-built_in">object</span>()， Self);<br>    Trigger-&gt;<span class="hljs-built_in">unpark</span>() ; <span class="hljs-comment">// 唤醒之前被pack()挂起的线程.</span><br>    <span class="hljs-comment">// Maintain stats and report events to JVMTI</span><br>    <span class="hljs-keyword">if</span> (ObjectMonitor::_sync_Parks != <span class="hljs-literal">NULL</span>) &#123;<br>        ObjectMonitor::_sync_Parks-&gt;<span class="hljs-built_in">inc</span>() ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>被唤醒的线程，会回到void ATTR ObjectMonitor::EnterI (TRAPS) 的第600行，继续执行monitor<br>的竞争</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// park self</span><br><span class="hljs-keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-built_in">TEVENT</span> (Inflated enter - park TIMED) ;<br>        Self-&gt;_ParkEvent-&gt;<span class="hljs-built_in">park</span> ((jlong) RecheckInterval) ;<br>        <span class="hljs-comment">// Increase the RecheckInterval， but clamp the value.</span><br>        RecheckInterval *= <span class="hljs-number">8</span> ;<br>        <span class="hljs-keyword">if</span> (RecheckInterval &gt; <span class="hljs-number">1000</span>) RecheckInterval = <span class="hljs-number">1000</span> ;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">TEVENT</span> (Inflated enter - park UNTIMED) ;<br>        Self-&gt;_ParkEvent-&gt;<span class="hljs-built_in">park</span>() ;<br>    &#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">TryLock</span>(Self) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span> ;<br></code></pre></td></tr></table></figure><h4 id="monitor是重量级锁"><a href="#monitor是重量级锁" class="headerlink" title="monitor是重量级锁"></a>monitor是重量级锁</h4><p>可以看到ObjectMonitor的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数，<br>执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个时候就<br>会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized是Java语<br>言中是一个重量级(Heavyweight)的操作。</p><p>用户态和和内核态是什么东西呢？要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/13.png" class=""></div><p>从上图可以看出，Linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。</p><p>内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境。</p><p>用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存<br>储资源、I&#x2F;O资源等。</p><p>系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p><p>所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；但是当它调用系统调用执<br>行某些操作时，例如 I&#x2F;O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内<br>核态）。 系统调用的过程可以简单理解为：</p><ol><li>用户态程序将一些数据值放在寄存器中， 或者使用参数创建一个堆栈， 以此表明需要操作系统提<br>供的服务。</li><li>用户态程序执行系统调用。</li><li>CPU切换到内核态，并跳到位于内存指定位置的指令。</li><li>系统调用处理器(system call handler)会读取程序放入内存的数据参数，并执行程序请求的服务。</li><li>系统调用完成后，操作系统会重置CPU为用户态并返回系统调用的结果。</li></ol><p>由此可见用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器<br>值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗，这就是在<br>synchronized未优化之前，效率低的原因。</p><h2 id="第六章：JDK6-synchronized优化"><a href="#第六章：JDK6-synchronized优化" class="headerlink" title="第六章：JDK6 synchronized优化"></a>第六章：JDK6 synchronized优化</h2><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><hr><h4 id="目标-13"><a href="#目标-13" class="headerlink" title="目标"></a>目标</h4><p>学习CAS的作用</p><p>学习CAS的原理</p><h4 id="CAS概述和作用"><a href="#CAS概述和作用" class="headerlink" title="CAS概述和作用"></a>CAS概述和作用</h4><p>CAS的全成是： Compare And Swap(比较相同再交换)。是现代CPU广泛支持的一种对内存中的共享数<br>据进行操作的一种特殊指令。</p><p>CAS的作用：CAS可以将比较和交换转换为原子操作，这个原子操作直接由CPU保证。CAS可以保证共<br>享变量赋值时的原子操作。CAS操作依赖3个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧<br>的预估值X等于内存中的值V，就将新的值B保存到内存中。</p><h4 id="CAS和volatile实现无锁并发"><a href="#CAS和volatile实现无锁并发" class="headerlink" title="CAS和volatile实现无锁并发"></a>CAS和volatile实现无锁并发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.huajframe.demo05_cas;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            atomicInteger.incrementAndGet();<br>         &#125;<br>      &#125;;<br><br>      List&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>         <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(run);<br>         thread.start();<br>         list.add(thread);<br>      &#125;<br><br>      <span class="hljs-keyword">for</span>(Thread t : list)&#123;<br>         t.join();<br>      &#125;<br>      System.out.println(<span class="hljs-string">&quot;number = &quot;</span> + atomicInteger.get());<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h4><p>通过刚才AtomicInteger的源码我们可以看到，Unsafe类提供了原子操作。</p><h4 id="Unsafe类介绍"><a href="#Unsafe类介绍" class="headerlink" title="Unsafe类介绍"></a>Unsafe类介绍</h4><p>Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使<br>用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。Unsafe对<br>象不能直接调用，只能通过反射获得</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/14.png" class=""></div><h4 id="Unsafe实现CAS"><a href="#Unsafe实现CAS" class="headerlink" title="Unsafe实现CAS"></a>Unsafe实现CAS</h4><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/15.png" class=""></div><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p>悲观锁从悲观的角度出发：</p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这<br>样别人想拿这个数据就会阻塞。因此synchronized我们也将其称之为悲观锁。JDK中的ReentrantLock<br>也是一种悲观锁。性能较差！</p><p>乐观锁从乐观的角度出发:</p><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系，再重试即可。所<br>以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如何没有人修改则更<br>新，如果有人修改则重试。</p><p>CAS这种机制我们也可以将其称之为乐观锁。综合性能较好！</p><blockquote><p>CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以<br>实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p><ol><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</li></ol></blockquote><h4 id="小结-12"><a href="#小结-12" class="headerlink" title="小结"></a>小结</h4><p>CAS的作用? Compare And Swap，CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理<br>器保证。</p><p>CAS的原理？CAS需要3个值:内存地址V，旧的预期值A，要修改的新值B，如果内存地址V和旧的预期值<br>A相等就修改内存地址值为B</p><h3 id="synchronized锁升级过程"><a href="#synchronized锁升级过程" class="headerlink" title="synchronized锁升级过程"></a>synchronized锁升级过程</h3><hr><p>高效并发是从JDK 5到JDK 6的一个重要改进，HotSpot虛拟机开发团队在这个版本上花费了大量的精力<br>去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性<br>自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为<br>了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p><p>无锁–》偏向锁–》轻量级锁–》重量级锁</p><h3 id="Java对象的布局"><a href="#Java对象的布局" class="headerlink" title="Java对象的布局"></a>Java对象的布局</h3><hr><h4 id="目标-14"><a href="#目标-14" class="headerlink" title="目标"></a>目标</h4><p>学习Java对象的布局</p><p>术语参考: <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html</a></p><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示：</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/16.png" class=""></div><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>当一个线程尝试访问synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是<br>存在锁对象的对象头中的。</p><p>HotSpot采用instanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述数组类<br>型。instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，另外，arrayOopDesc<br>的定义对应 arrayOop.hpp 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">instanceOopDesc</span> : <span class="hljs-keyword">public</span> oopDesc &#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">// aligned header size.</span><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">header_size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">sizeof</span>(instanceOopDesc)/HeapWordSize; &#125;<br>   <span class="hljs-comment">// If compressed, the offset of the fields of the instance may not be aligned.</span><br>   <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">base_offset_in_bytes</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-comment">// offset computation code breaks if UseCompressedClassPointers</span><br>   <span class="hljs-comment">// only is true</span><br>   <span class="hljs-keyword">return</span> (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ?<br>            <span class="hljs-built_in">klass_gap_offset_in_bytes</span>() :<br>            <span class="hljs-built_in">sizeof</span>(instanceOopDesc);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">contains_field_offset</span><span class="hljs-params">(<span class="hljs-type">int</span> offset, <span class="hljs-type">int</span> nonstatic_field_size)</span> </span>&#123;<br>         <span class="hljs-type">int</span> base_in_bytes = <span class="hljs-built_in">base_offset_in_bytes</span>();<br>         <span class="hljs-keyword">return</span> (offset &gt;= base_in_bytes &amp;&amp;<br>                (offset-base_in_bytes) &lt; nonstatic_field_size * heapOopSize);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，oopDesc的定义载Hotspot<br>源码中的 oop.hpp 文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">oopDesc</span> &#123;<br>   <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VMStructs</span>;<br>   <span class="hljs-keyword">private</span>:<br>      <span class="hljs-keyword">volatile</span> markOop _mark;<br>      <span class="hljs-keyword">union</span> <span class="hljs-title class_">_metadata</span> &#123;<br>         Klass* _klass;<br>         narrowKlass _compressed_klass;<br>      &#125; _metadata;<br>      <span class="hljs-comment">// Fast access to barrier set. Must be initialized.</span><br>      <span class="hljs-type">static</span> BarrierSet* _bs;<br>      <span class="hljs-comment">// 省略其他代码</span><br>&#125;;<br></code></pre></td></tr></table></figure><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/16.png" class=""></div><p>在普通实例对象中，oopDesc的定义包含两个成员，分别是 _mark 和 _metadata</p><p>_mark 表示对象标记、属于markOop类型，也就是接下来要讲解的Mark World，它记录了对象和锁有<br>关的信息</p><p>_metadata 表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中Klass表示<br>普通指针、 _compressed_klass 表示压缩类指针。</p><p>对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指<br>针，及对象指向它的类元数据的指针。</p><h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、<br>线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。Mark Word对应的类<br>型是markOop 。源码位于markOop.hpp 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Bit-format of an object header (most significant first, big endian layout below):</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 32 bits:</span><br><span class="hljs-comment">// --------</span><br><span class="hljs-comment">// hash:25 ------------&gt;| age:4 biased_lock:1 lock:2 (normal object)</span><br><span class="hljs-comment">// JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object)</span><br><span class="hljs-comment">// size:32 ------------------------------------------&gt;| (CMS free block)</span><br><span class="hljs-comment">// PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 64 bits:</span><br><span class="hljs-comment">// --------</span><br><span class="hljs-comment">// unused:25 hash:31 --&gt;| unused:1 age:4 biased_lock:1 lock:2 (normal object)</span><br><span class="hljs-comment">// JavaThread*:54 epoch:2 unused:1 age:4 biased_lock:1 lock:2 (biased object)</span><br><span class="hljs-comment">// PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)</span><br><span class="hljs-comment">// size:64 -----------------------------------------------------&gt;| (CMS free block)</span><br><span class="hljs-comment">// [JavaThread* | epoch | age | 1 | 01] lock is biased toward given thread</span><br><span class="hljs-comment">// [0 | epoch | age | 1 | 01] lock is anonymously biased</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// - the two lock bits are used to describe three states: locked/unlocked and monitor.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// [ptr | 00] locked ptr points to real header on stack</span><br><span class="hljs-comment">// [header | 0 | 01] unlocked regular object header</span><br><span class="hljs-comment">// [ptr | 10] monitor inflated lock (header is wapped out)</span><br><span class="hljs-comment">// [ptr | 11] marked used by markSweep to mark an object</span><br><span class="hljs-comment">// not valid at any other time</span><br></code></pre></td></tr></table></figure><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/17.png" class=""></div><p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/18.png" class=""></div><p>在32位虚拟机下，Mark Word是32bit大小的，其存储结构如下：</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/19.png" class=""></div><h4 id="klass-pointer"><a href="#klass-pointer" class="headerlink" title="klass pointer"></a>klass pointer</h4><p>这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的<br>实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。 如果应用的对<br>象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内<br>存。为了节约内存可以使用选项-XX:+UseCompressedOops 开启指针压缩，其中，oop即ordinary<br>object pointer普通对象指针。开启该选项后，下列指针将压缩至32位：</p><ol><li>每个Class的属性指针（即静态变量）</li><li>每个对象的属性指针（即对象变量）</li><li>普通对象数组的每个元素指针</li></ol><p>当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对<br>象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。</p><p>对象头 &#x3D; Mark Word + 类型指针（未开启指针压缩的情况下）</p><p>在32位系统中，Mark Word &#x3D; 4 bytes，类型指针 &#x3D; 4bytes，对象头 &#x3D; 8 bytes &#x3D; 64 bits；</p><p>在64位系统中，Mark Word &#x3D; 8 bytes，类型指针 &#x3D; 8bytes，对象头 &#x3D; 16 bytes &#x3D; 128bits；</p><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>就是类中定义的成员变量。</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于HotSpot VM的<br>自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的<br>整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充<br>来补全。</p><h4 id="查看Java对象布局"><a href="#查看Java对象布局" class="headerlink" title="查看Java对象布局"></a>查看Java对象布局</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jol<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jol-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="小结-13"><a href="#小结-13" class="headerlink" title="小结"></a>小结</h4><p>Java对象由3部分组成，对象头，实例数据，对齐数据</p><p>对象头分成两部分：Mark World + Klass pointer</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><hr><h4 id="目标-15"><a href="#目标-15" class="headerlink" title="目标"></a>目标</h4><p>学习偏向锁的原理和好处</p><h4 id="什么是偏向锁"><a href="#什么是偏向锁" class="headerlink" title="什么是偏向锁"></a>什么是偏向锁</h4><p>偏向锁是JDK 6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多<br>线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。</p><p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对<br>象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及<br>ThreadID即可。</p><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/18.png" class=""></div><p>不过一旦出现多个线程竞争时必须撤销偏向锁，所以撤销偏向锁消耗的性能必须小于之前节省下来的<br>CAS原子操作的性能消耗，不然就得不偿失了。</p><h4 id="偏向锁原理"><a href="#偏向锁原理" class="headerlink" title="偏向锁原理"></a>偏向锁原理</h4><p>当线程第一次访问同步块并获取锁时，偏向锁处理流程如下：</p><blockquote><ol><li>虚拟机将会把对象头中的标志位设为“01”，即偏向模式。</li><li>同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，<br>如果CAS操作 成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，<br>虚拟机都可以不再进行任何 同步操作，偏向锁的效率高。</li></ol></blockquote><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/18.png" class=""></div><p>持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁<br>的效率高。</p><h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><ol><li>偏向锁的撤销动作必须等待全局安全点</li><li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态</li><li>撤销偏向锁，恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态</li></ol><p>偏向锁在Java 6之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用-<br>XX:BiasedLockingStartupDelay&#x3D;0 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争<br>状态，可以通过XX:-UseBiasedLocking&#x3D;false 参数关闭偏向锁。</p><h4 id="偏向锁好处"><a href="#偏向锁好处" class="headerlink" title="偏向锁好处"></a>偏向锁好处</h4><p>偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向<br>锁可以提高带有同步但无竞争的程序性能。</p><p>它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多<br>数的锁总是被多个不同的线程访问比如线程池，那偏向模式就是多余的。</p><p>在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。但在应用程序启动几秒钟之后才<br>激活，可以使用-XX:BiasedLockingStartupDelay&#x3D;0 参数关闭延迟，如果确定应用程序中所有锁通常<br>情况下处于竞争状态，可以通过XX:-UseBiasedLocking&#x3D;false 参数关闭偏向锁。</p><h4 id="小结-14"><a href="#小结-14" class="headerlink" title="小结"></a>小结</h4><p>偏向锁的原理是什么?</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操<br>作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每<br>次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。<br></code></pre></td></tr></table></figure><p>偏向锁的好处是什么?</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以<br>提高带有同步但无竞争的程序性能。<br></code></pre></td></tr></table></figure><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><hr><h4 id="目标-16"><a href="#目标-16" class="headerlink" title="目标"></a>目标</h4><p>学习轻量级锁的原理和好处</p><h4 id="什么是轻量级锁"><a href="#什么是轻量级锁" class="headerlink" title="什么是轻量级锁"></a>什么是轻量级锁</h4><p>轻量级锁是JDK 6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用monitor的传统锁而言的，<br>因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。</p><p>引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如<br>果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要<br>替代重量级锁。</p><h4 id="轻量级锁原理"><a href="#轻量级锁原理" class="headerlink" title="轻量级锁原理"></a>轻量级锁原理</h4><p>当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步<br>骤如下： 获取锁</p><ol><li>判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则JVM首先将在当前线程的栈帧<br>中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方<br>把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），将对象的Mark Word复制到栈<br>帧中的Lock Record中，将Lock Reocrd中的owner指向当前对象。</li><li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到<br>锁，则将锁标志位变成00，执行同步操作。</li><li>如果失败则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持<br>有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻<br>量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态。</li></ol><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/20.png" class=""></div><h4 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h4><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据。</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功。</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级<br>锁。</li></ol><p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如<br>果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁<br>比重量级锁更慢。</p><h4 id="轻量级锁好处"><a href="#轻量级锁好处" class="headerlink" title="轻量级锁好处"></a>轻量级锁好处</h4><p>在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p><h4 id="小结-15"><a href="#小结-15" class="headerlink" title="小结"></a>小结</h4><p>轻量级锁的原理是什么？</p><p>将对象的Mark Word复制到栈帧中的Lock Recod中。Mark Word更新为指向Lock Record的指针。</p><p>轻量级锁好处是什么？</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。<br></code></pre></td></tr></table></figure><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><hr><h4 id="目标-17"><a href="#目标-17" class="headerlink" title="目标"></a>目标</h4><p>学习自旋锁原理</p><h4 id="自旋锁原理"><a href="#自旋锁原理" class="headerlink" title="自旋锁原理"></a>自旋锁原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (Demo01.class) &#123;<br>    ...<br>    System.out.println(<span class="hljs-string">&quot;aaa&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>前面我们讨论monitor实现锁的时候，知道monitor会阻塞和唤醒线程，线程的阻塞和唤醒需要CPU从<br>用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，这些操作给系统的并发性能<br>带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很<br>短的一段时间，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个<br>或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行<br>时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环(自<br>旋) , 这项技术就是所谓的自旋锁。</p><p>自旋锁在JDK 1.4.2中就已经引入 ，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开启，在<br>JDK 6中 就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本<br>身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等<br>待的效果就会非常好，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而<br>不会做任何有用的工作，反而会带来性 能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果<br>自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值<br>是10次，用户可以使用参数-XX : PreBlockSpin来更改。</p><h4 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h4><p>在JDK 6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上<br>的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持<br>有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持<br>续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取<br>这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控<br>信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><hr><h4 id="目标-18"><a href="#目标-18" class="headerlink" title="目标"></a>目标</h4><p>学习如何进行锁消除</p><p>锁消除是指虚拟机即时编译器（JIT）在运行时，对一些代码上要求同步，但是被检测到不可能存在共享<br>数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，<br>堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们<br>是线程私有的，同步加锁自然就无须进行。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确<br>定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有<br>许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的<br>想象。下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上<br>都没有同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        contactString(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">contactString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>().append(s1).append(s2).append(s3).toString();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>StringBuffer的append ( ) 是一个同步方法，锁就是this也就是(new StringBuilder())。虚拟机发现它的<br>动态作用域被限制在concatString( )方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃<br>逸”到concatString ( )方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除<br>掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><hr><h4 id="目标-19"><a href="#目标-19" class="headerlink" title="目标"></a>目标</h4><p>学习锁粗化的原理</p><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作<br>用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线<br>程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对<br>象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操<br>作也会导致不必要的性能损耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            sb.append(<span class="hljs-string">&quot;aa&quot;</span>);<br>        &#125;<br>        System.out.println(sb.toString());<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-16"><a href="#小结-16" class="headerlink" title="小结"></a>小结</h4><p>什么是锁粗化？JVM会探测到一连串细小的操作都使用同一个对象加锁，将同步代码块的范围放大，放<br>到这串操作的外面，这样只需要加一次锁即可。</p><h3 id="平时写代码如何对synchronized优化"><a href="#平时写代码如何对synchronized优化" class="headerlink" title="平时写代码如何对synchronized优化"></a>平时写代码如何对synchronized优化</h3><hr><h4 id="减少synchronized的范围"><a href="#减少synchronized的范围" class="headerlink" title="减少synchronized的范围"></a>减少synchronized的范围</h4><p>同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (Demo01.class) &#123;<br>    System.out.println(<span class="hljs-string">&quot;aaa&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="降低synchronized锁的粒度"><a href="#降低synchronized锁的粒度" class="headerlink" title="降低synchronized锁的粒度"></a>降低synchronized锁的粒度</h4><p>将一个锁拆分为多个锁提高并发度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Hashtable</span> <span class="hljs-variable">hs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>();<br>hs.put(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>);<br>hs.put(<span class="hljs-string">&quot;xx&quot;</span>, <span class="hljs-string">&quot;yy&quot;</span>);<br></code></pre></td></tr></table></figure><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/21.png" class=""></div><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/22.png" class=""></div><div align=center>    <img src="/2020/10/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3synchronized/23.png" class=""></div><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h4><p><font color="red">读取时不加锁，写入和删除时加锁</font> </p><p>ConcurrentHashMap，CopyOnWriteArrayList和ConyOnWriteSet</p>]]></content>
    
    
    <categories>
      
      <category>Java并发编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并发编程</tag>
      
      <tag>多线程</tag>
      
      <tag>同步锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型和泛型通配符</title>
    <link href="/2020/10/02/Java%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <url>/2020/10/02/Java%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1 泛型"></a>1 泛型</h3><h4 id="1-1-什么是泛型"><a href="#1-1-什么是泛型" class="headerlink" title="1.1 什么是泛型"></a>1.1 什么是泛型</h4><p>泛型是 Java SE5 出现的新特性，泛型的本质是<strong>类型参数化或参数化类型</strong>，在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。</p><h4 id="1-2-泛型的好处"><a href="#1-2-泛型的好处" class="headerlink" title="1.2 泛型的好处"></a>1.2 泛型的好处</h4><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p><p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p><h4 id="1-3-泛型的使用方式"><a href="#1-3-泛型的使用方式" class="headerlink" title="1.3 泛型的使用方式"></a>1.3 泛型的使用方式</h4><p><strong>泛型类，泛型接口，泛型方法</strong></p><h5 id="1-3-1-泛型类"><a href="#1-3-1-泛型类" class="headerlink" title="1.3.1 泛型类"></a>1.3.1 泛型类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setKey</span><span class="hljs-params">(T key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的T可以换成任意标识符，但约定俗成的常用<code>E,T,K,N,V,?</code>表示</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">E</span><span class="hljs-operator">-</span><span class="hljs-built_in">Element</span>（在集合中使用，因为集合中存放的是元素）<br><span class="hljs-variable">T</span><span class="hljs-operator">-</span><span class="hljs-variable">Type</span>（<span class="hljs-variable">Java</span>类）<br><span class="hljs-built_in">K</span><span class="hljs-operator">-</span><span class="hljs-built_in">Key</span>（键）<br><span class="hljs-built_in">N</span><span class="hljs-operator">-</span><span class="hljs-built_in">Number</span>（数值类型）<br><span class="hljs-variable">V</span><span class="hljs-operator">-</span><span class="hljs-built_in">Value</span><span class="hljs-punctuation">(</span>值<span class="hljs-punctuation">)</span><br><span class="hljs-operator">?-</span>表示不确定的<span class="hljs-variable">java</span>类型<br></code></pre></td></tr></table></figure><p>如何实例化泛型类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Generic&lt;String&gt; generic = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;String&gt;();<br></code></pre></td></tr></table></figure><h5 id="1-3-2-泛型接口"><a href="#1-3-2-泛型接口" class="headerlink" title="1.3.2.泛型接口"></a>1.3.2.泛型接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;szh&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-3-3-泛型方法"><a href="#1-3-3-泛型方法" class="headerlink" title="1.3.3 泛型方法"></a>1.3.3 泛型方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(List&lt;E&gt; list)</span>&#123;<br>    <span class="hljs-keyword">for</span> (E e : list) &#123;<br>        System.out.println(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//创建不同类型的list----String和Integer</span><br>List&lt;String&gt; strings = Arrays.asList(<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>);<br>List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>printList(strings);<br>printList(integers);<br></code></pre></td></tr></table></figure><p>注意: <code>public static &lt;E&gt; void printList(List&lt;E&gt; list)</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p><h3 id="2-泛型的通配符"><a href="#2-泛型的通配符" class="headerlink" title="2 泛型的通配符"></a>2 泛型的通配符</h3><h4 id="2-1-无界通配符-lt-gt"><a href="#2-1-无界通配符-lt-gt" class="headerlink" title="2.1 无界通配符&lt;?&gt;"></a>2.1 无界通配符<code>&lt;?&gt;</code></h4><p>我有一个父类 <code>Fruit</code> 和几个子类，如<code>Apple</code>,<code>Pear</code>等，现在我需要一个水果的列表，我的第一个想法是像这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">List<span class="hljs-tag">&lt;<span class="hljs-name">Fruit</span>&gt;</span> Fruits<br></code></pre></td></tr></table></figure><p>但是老板的想法确实这样的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">List<span class="hljs-meta">&lt;?</span> <span class="hljs-keyword">extends</span> Fruit&gt; fruits<br></code></pre></td></tr></table></figure><p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countFruits</span><span class="hljs-params">(List&lt;? extends Fruit&gt; fruits)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Fruit fruit : fruits) &#123;<br>        System.out.println(fruit.getName());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">countFruits1</span><span class="hljs-params">(List&lt;Fruit&gt; fruits)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Fruit fruit : fruits) &#123;<br>        System.out.println(fruit.getName());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">// 不会报错</span><br>    countFruits(apples);<br>    <span class="hljs-comment">// 报错</span><br>    countFruits1(apples);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后提示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java: 不兼容的类型: java<span class="hljs-selector-class">.util</span>.List&lt;fanxing<span class="hljs-selector-class">.demo05</span>.Apple&gt;无法转换为<br>java<span class="hljs-selector-class">.util</span>.List&lt;fanxing<span class="hljs-selector-class">.demo05</span>.Fruit&gt;<br></code></pre></td></tr></table></figure><p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符<code>&lt;?&gt;</code>，表示可以持有任何类型。<code>countFruits</code>方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的<code>Fruit</code>的所有子类都可以支持，并且不会报错。而 <code>countFruits1</code> 就不行。**<code>LIst&lt;?&gt;</code>相当于<code>LIst&lt;? extends Object&gt;</code>**</p><h4 id="2-2-上界通配符-lt-extends-E-gt"><a href="#2-2-上界通配符-lt-extends-E-gt" class="headerlink" title="2.2 上界通配符 &lt; ? extends E&gt;"></a>2.2 上界通配符 <code>&lt; ? extends E&gt;</code></h4><p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p><ul><li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li><li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(List&lt;? extends Number&gt; numbers)</span>&#123;<br>        <span class="hljs-keyword">for</span> (Number number : numbers) &#123;<br>            System.out.println(number);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        List&lt;Integer&gt; integers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>));<br>        <span class="hljs-comment">//通过</span><br>        test.print(integers);<br><br>        List&lt;Double&gt; doubles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1D</span>,<span class="hljs-number">2D</span>,<span class="hljs-number">3D</span>));<br>        <span class="hljs-comment">//通过</span><br>        test.print(doubles);<br><br>        List&lt;String&gt; strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>));<br>        <span class="hljs-comment">//不通过</span><br>        <span class="hljs-comment">// test.print(strings);</span><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>上述代码中<code>print</code>方法只能传入<code>Number</code>及<code>Number</code>子类的集合，传入<code>String</code>的集合后编译不通过</li></ul><p><strong>注意</strong>：<br>对于上限通配符需要注意的一点就是使用上限通配符<strong>只能从结构中获取值而不能将值放入结构中</strong>。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&gt; ls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">Apple</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br><span class="hljs-type">Pear</span> <span class="hljs-variable">pear</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pear</span>();<br><span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>();<br><span class="hljs-comment">//报错</span><br>ls.add(fruit);<br><span class="hljs-comment">//报错</span><br>ls.add(apple);<br><span class="hljs-comment">//报错</span><br>ls.add(pear);<br><span class="hljs-comment">//不报错</span><br><span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit1</span> <span class="hljs-operator">=</span> ls.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h4 id="2-3-下界通配符-lt-super-E-gt"><a href="#2-3-下界通配符-lt-super-E-gt" class="headerlink" title="2.3 下界通配符 &lt;? super E&gt;"></a>2.3 下界通配符 <code>&lt;? super E&gt;</code></h4><p>顾名思义，下界通配符就是已经规定好了下界，只能传入参数必须是<code>E</code>或者是<code>E</code>的父类。</p><p>如下是一个三级继承</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e6b329d3a1f410f828323594ef6fd2f~tplv-k3u1fbpfcp-watermark.image" alt="屏幕截图 2022-10-06 160330.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Pear&gt; pears)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;----&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Test2</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test2</span>();<br>        List&lt;Fruit&gt; fruits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//通过</span><br>        test.print(fruits);<br><br>        List&lt;Pear&gt; pears = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//通过</span><br>        test.print(pears);<br><br>        List&lt;FragrantPear&gt; fragrantPears = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//不通过</span><br>        test.print(fragrantPears);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码可见<code>Pear</code>及其父类的集合可以传入<code>print</code>方法中，但是<code>Pear</code>的子类<code>FragrantPear</code>的集合却不行。</p><p><strong>注意</strong>：<br>对于下限通配符需要注意的一点就是使用下限通配符<strong>只能将值放入结构中或者将读取结果转换为Object</strong>。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;? <span class="hljs-built_in">super</span> Fruit&gt; ls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">Apple</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br><span class="hljs-type">Pear</span> <span class="hljs-variable">pear</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pear</span>();<br><span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>();<br><span class="hljs-comment">//不报错</span><br>ls.add(fruit);<br><span class="hljs-comment">//不报错</span><br>ls.add(apple);<br><span class="hljs-comment">//不报错</span><br>ls.add(pear);<br><span class="hljs-comment">//不报错</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> ls.get(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//不报错</span><br><span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit1</span> <span class="hljs-operator">=</span> (Fruit) ls.get(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//报错</span><br><span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit2</span> <span class="hljs-operator">=</span> ls.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h4 id="2-4-多重边界限定"><a href="#2-4-多重边界限定" class="headerlink" title="2.4 多重边界限定"></a>2.4 多重边界限定</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">public static &lt;<span class="hljs-built_in">T</span> extends Number &amp; Comparable&lt;<span class="hljs-built_in">T</span>&gt;&gt; <span class="hljs-built_in">T</span> maximum(<span class="hljs-built_in">T</span> x, <span class="hljs-built_in">T</span> y, <span class="hljs-built_in">T</span> z)<br></code></pre></td></tr></table></figure><p>T是传递给泛型类的类型参数应该是Number类的子类型，并且必须包含Comparable接口。<br>如果一个类作为绑定传递，它应该在接口之前先传递，否则编译时会发生错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericMoreTypeExtends</span> &#123; <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br>        System.out.println(maxMum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)); <br>        System.out.println(maxMum(<span class="hljs-number">1.1</span>,<span class="hljs-number">2.2</span>,<span class="hljs-number">3.3</span>)); <br>    &#125; <br>    <br>    <span class="hljs-comment">//限制类型参数T必须实现Comparable 和 必须是Number的子类，限制上界 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> &amp; Comparable&lt;T&gt;&gt; T <span class="hljs-title function_">maxMum</span><span class="hljs-params">(T x, T y, T z)</span> &#123; <br>        <span class="hljs-type">T</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> x; <br>        <span class="hljs-keyword">if</span> (y.compareTo(max) &gt; <span class="hljs-number">0</span>) &#123; <br>            max = y; <br>        &#125; <br>        <span class="hljs-keyword">if</span> (z.compareTo(max) &gt; <span class="hljs-number">0</span>) &#123; <br>            max = z; <br>        &#125; <br>        <span class="hljs-keyword">return</span> max; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>而<code>System.out.println(maxMum(&quot;s&quot;,&quot;z&quot;,&quot;h&quot;));</code>编译则不会通过!</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的String学习总结</title>
    <link href="/2020/09/28/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84String%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/28/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84String%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="1-String是不可变的"><a href="#1-String是不可变的" class="headerlink" title="1 String是不可变的"></a>1 <code>String</code>是不可变的</h3><h4 id="1-1-首先String是不可变的，具体原因主要有以下两点"><a href="#1-1-首先String是不可变的，具体原因主要有以下两点" class="headerlink" title="1.1 首先String是不可变的，具体原因主要有以下两点"></a>1.1 首先<code>String</code>是不可变的，具体原因主要有以下两点</h4><ol><li><code>String</code>中保存字符串的数组被<code>final</code>修饰且是私有属性，而且<code>String</code>没有暴露给外界任何可以修改该字符串的方法；</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>注意：JDK9及后将保存字符串的数组由<code>char</code>改为了<code>byte</code></li></ol><p>详细参见：<a href="https://www.zhihu.com/question/20618891/answer/114125846" title="如何理解 String 类型值的不可变？">如何理解 String 类型值的不可变？</a></p><h4 id="1-2-既然String不可变那它是怎样实现修改的呢？"><a href="#1-2-既然String不可变那它是怎样实现修改的呢？" class="headerlink" title="1.2 既然String不可变那它是怎样实现修改的呢？"></a>1.2 既然<code>String</code>不可变那它是怎样实现修改的呢？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br>s = <span class="hljs-string">&quot;2&quot;</span>;<br></code></pre></td></tr></table></figure><p>上述代码转换为字节码后</p><div align=center>    <img src="/2020/09/28/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84String%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/10004.jpg" class="" title="加载失败"></div><p>上述字节码表示会在字符串常量池中新建一个字符串并加载</p><h3 id="2-String拼接"><a href="#2-String拼接" class="headerlink" title="2 String拼接"></a>2 <code>String</code>拼接</h3><h4 id="2-1-拼接方式"><a href="#2-1-拼接方式" class="headerlink" title="2.1 拼接方式"></a>2.1 拼接方式</h4><p><code>String</code>有两种拼接字符串方法</p><ul><li><code>+</code>和<code>+=</code>拼接</li><li><code>StringBuilder</code>和<code>StringBuffer</code>的<code>append(String str)</code>方法，拼接完成后调用他们的<code>toString()</code>方法获得<code>String</code>对象</li></ul><p><strong>注意</strong>：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">String</span> 中的对象是不可变的，也就可以理解为常量，线程安全;<br><span class="hljs-built_in">StringBuffer</span> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加<br>同步锁，所以是非线程安全的。<br></code></pre></td></tr></table></figure><h4 id="2-2-和-拼接的实质"><a href="#2-2-和-拼接的实质" class="headerlink" title="2.2 +和+=拼接的实质"></a>2.2 <code>+</code>和<code>+=</code>拼接的实质</h4><p>实际上<code>+</code>和<code>+=</code>是Java专门为<code>String</code>重载的运算符，java本身是不支持运算符重载的，<code>+</code>和<code>+=</code>也是 Java 中仅有的两个重载过的运算符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zh&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<br></code></pre></td></tr></table></figure><p>上述代码对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zh&quot;</span>;<br>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>()).append(str1).append(str2).toString();<br></code></pre></td></tr></table></figure><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56ab1aedc97546908c74352416442b09~tplv-k3u1fbpfcp-watermark.image" alt="2.png"><br>由字节码看出实际上是由<code>StringBuilder</code>实现拼接的</p><h4 id="2-3-注意"><a href="#2-3-注意" class="headerlink" title="2.3 注意"></a>2.3 注意</h4><p>有一点注意的是：在循环内最好不要用<code>+</code>和<code>+=</code>来拼接字符串，因为不会在循环外部创建一个<code>StringBuild</code>对象来进行复用，而是在每次循环是都会创建一个<code>StringBuild</code>对象，造成资源的浪费</p><h5 id="2-3-1-拼接"><a href="#2-3-1-拼接" class="headerlink" title="2.3.1 +=拼接"></a>2.3.1 <code>+=</code>拼接</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">for</span> (String value : arr) &#123;<br>    str += value;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码在循环体内部创建<code>StringBuild</code>对象：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/851a6ceee3074ec8ba3c04de82f2afbd~tplv-k3u1fbpfcp-watermark.image" alt="Snipaste_2022-10-02_14-49-03.png"></p><h5 id="2-3-2-循环外部创建StringBuild对象"><a href="#2-3-2-循环外部创建StringBuild对象" class="headerlink" title="2.3.2 循环外部创建StringBuild对象"></a>2.3.2 循环外部创建<code>StringBuild</code>对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">for</span> (String value : arr) &#123;<br>    s.append(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码只创建了一个<code>StringBuild</code>对象<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc9bb12d712e47c1a57ea16fa96334b4~tplv-k3u1fbpfcp-watermark.image" alt="3.png"></p><h3 id="3-符串常量池"><a href="#3-符串常量池" class="headerlink" title="3 符串常量池"></a>3 符串常量池</h3><h4 id="3-1-什么是字符串常量池"><a href="#3-1-什么是字符串常量池" class="headerlink" title="3.1 什么是字符串常量池"></a>3.1 什么是字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;111&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;111&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;111&quot;</span>);<br><span class="hljs-comment">//str1和str2都是常量池中的地址，所以他们是相同的</span><br>System.out.println(str1 == str2); <span class="hljs-comment">//true</span><br><span class="hljs-comment">//str1是常量池中的地址，str3是堆内存中的地址</span><br>System.out.println(str1 == str3);  <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>注意：在 Jdk6 以及以前的版本中，字符串的常量池是放在堆的 Perm 区的，Perm 区是一个类静态的区域，主要存储一些加载类的信息，常量池，方法片段等内容，默认大小只有4m，一旦常量池中大量使用 intern 是会直接产生<code>java.lang.OutOfMemoryError: PermGen space</code>错误的。 所以在 jdk7 的版本中，字符串常量池已经从 Perm 区移到正常的 Java Heap 区域了。为什么要移动，Perm 区域太小是一个主要原因，当然据消息称 jdk8 已经直接取消了 Perm 区域，而新建立了一个元区域。应该是 jdk 开发者认为 Perm 区域已经不适合现在 JAVA 的发展了。</p><h4 id="3-2-String-s1-x3D-new-String-“111”-这句话创建了几个字符串对象？"><a href="#3-2-String-s1-x3D-new-String-“111”-这句话创建了几个字符串对象？" class="headerlink" title="3.2 String s1 &#x3D; new String(“111”);这句话创建了几个字符串对象？"></a>3.2 String s1 &#x3D; new String(“111”);这句话创建了几个字符串对象？</h4><p>答：会创建1个或两个对象</p><h5 id="3-2-1-如果常量池中不存在111字符串，那么该句子会创建两个对象，在堆区创建一个字符串对象，在常量池中创建一个对象"><a href="#3-2-1-如果常量池中不存在111字符串，那么该句子会创建两个对象，在堆区创建一个字符串对象，在常量池中创建一个对象" class="headerlink" title="3.2.1 如果常量池中不存在111字符串，那么该句子会创建两个对象，在堆区创建一个字符串对象，在常量池中创建一个对象"></a>3.2.1 如果常量池中不存在<code>111</code>字符串，那么该句子会创建两个对象，在堆区创建一个字符串对象，在常量池中创建一个对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;111&quot;</span>);<br></code></pre></td></tr></table></figure><p>对应的字节码：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0faf1ff599714be0a1efb95ee1bda147~tplv-k3u1fbpfcp-watermark.image" alt="5.png"><br><code>ldc</code> 命令用于判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。</p><h5 id="3-2-2-如果常量池中存在111字符串，那么该句子指挥创建一个对象，即在堆区创建一个字符串对象"><a href="#3-2-2-如果常量池中存在111字符串，那么该句子指挥创建一个对象，即在堆区创建一个字符串对象" class="headerlink" title="3.2.2 如果常量池中存在111字符串，那么该句子指挥创建一个对象，即在堆区创建一个字符串对象"></a>3.2.2 如果常量池中存在<code>111</code>字符串，那么该句子指挥创建一个对象，即在堆区创建一个字符串对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;111&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;111&quot;</span>);<br></code></pre></td></tr></table></figure><p>对应的字节码：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e67b6a73da54772bdc99dd383e65fbb~tplv-k3u1fbpfcp-watermark.image" alt="4.png"></p><p>第7行已经存在就不会再添加了</p><h4 id="3-3-String的intern方法"><a href="#3-3-String的intern方法" class="headerlink" title="3.3 String的intern方法"></a>3.3 <code>String</code>的<code>intern</code>方法</h4><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：</p><ul><li>如果字符串常量池中保存了对应的字符串，就直接返回该引用</li><li>如果字符串常量池中没有保存对应的字符串，那就在常量池中创建一个指向该字符串对象的引用并返回</li></ul><p>示例代码（JDK 8） :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在堆中创建字符串对象”Java“</span><br><span class="hljs-comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Java&quot;</span>;<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br><span class="hljs-comment">// 会在堆中在单独创建一个字符串对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br><span class="hljs-comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s3.intern();<br><span class="hljs-comment">// s1 和 s2 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// s3 和 s4 指向的是堆中不同的对象</span><br>System.out.println(s3 == s4); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// s1 和 s4 指向的是堆中的同一个对象</span><br>System.out.println(s1 == s4); <span class="hljs-comment">//true</span><br><br></code></pre></td></tr></table></figure><p>摘自：<a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#intern-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">Java Guide intern 方法有什么作用</a></p><p>更加详细的解释：<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">深入解析String#intern</a></p><h3 id="4-常量折叠"><a href="#4-常量折叠" class="headerlink" title="4 常量折叠"></a>4 常量折叠</h3><h4 id="4-1-无final修饰"><a href="#4-1-无final修饰" class="headerlink" title="4.1 无final修饰"></a>4.1 无final修饰</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zh&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span> + <span class="hljs-string">&quot;zh&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<br></code></pre></td></tr></table></figure><p>字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zh&quot;</span>;<br><span class="hljs-comment">//直接拼接了</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;szh&quot;</span>;<br>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>()).append(str1).append(str2).toString();<br></code></pre></td></tr></table></figure><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p><p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串常量。</li><li><code>final</code> 修饰的基本数据类型和字符串变量</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul><p><strong>引用的值在程序编译期是无法确定的，编译器无法对其进行优化。</strong></p><h4 id="4-2-与final修饰"><a href="#4-2-与final修饰" class="headerlink" title="4.2 与final修饰"></a>4.2 与final修饰</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zh&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span> + <span class="hljs-string">&quot;zh&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> str1 + str2;<br></code></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;s&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zh&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;szh&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;szh&quot;</span>;<br><span class="hljs-comment">//str3和str4都进行了折叠</span><br></code></pre></td></tr></table></figure><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p><p>详细介绍：<a href="https://www.zhihu.com/question/55976094/answer/147302764">常量折叠</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Java Guide Java基础常见面试题总结(中) String &amp;nbsp;&amp;nbsp;&amp;nbsp;<a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#string">https://javaguide.cn/java/basis/java-basic-questions-02.html#string</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的深拷贝和浅拷贝</title>
    <link href="/2020/09/24/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2020/09/24/Java%E5%9F%BA%E7%A1%80/Java%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。<br>​<br><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。<br>​</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>我们实现<code>Cloneable</code>接口，重写<code>clone()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String addressName;<br>​<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String addressName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.addressName = addressName;<br>    &#125;<br>​<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAddressName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> addressName;<br>    &#125;<br>​<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddressName</span><span class="hljs-params">(String addressName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.addressName = addressName;<br>    &#125;<br>​<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Address <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> (Address) <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;长沙&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> person.clone();<br>System.out.println(person == person1);  <span class="hljs-comment">//输出false</span><br>System.out.println(person.getAddress() == person1.getAddress()); <span class="hljs-comment">//输出true</span><br></code></pre></td></tr></table></figure><p>两个Address都指向同一块内存中的数据</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>修改浅拷贝的<code>Person</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> Address address;<br>​<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(Address address)</span>&#123;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br>​<br>    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">getAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br>​<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAddress</span><span class="hljs-params">(Address address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br>​<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>        person.setAddress(person.getAddress().clone());<br>        <span class="hljs-keyword">return</span> person;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Person person <span class="hljs-operator">=</span> new Person(new Address(<span class="hljs-string">&quot;长沙&quot;</span>))<span class="hljs-comment">;</span><br>Person person1 <span class="hljs-operator">=</span> person.clone()<span class="hljs-comment">;</span><br>System.out.println(person <span class="hljs-operator">=</span><span class="hljs-operator">=</span> person1)<span class="hljs-comment">;  //输出false</span><br>System.out.println(person.getAddress() <span class="hljs-operator">=</span><span class="hljs-operator">=</span> person1.getAddress())<span class="hljs-comment">; //输出false</span><br></code></pre></td></tr></table></figure><p>person1的address也已经被clone<br>​</p><h3 id="引用拷贝、浅拷贝、深拷贝三者区别"><a href="#引用拷贝、浅拷贝、深拷贝三者区别" class="headerlink" title="引用拷贝、浅拷贝、深拷贝三者区别"></a>引用拷贝、浅拷贝、深拷贝三者区别</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d57e5bf73f054ad096e7364b1740cf82~tplv-k3u1fbpfcp-watermark.image" alt="shallow&amp;deep-copy.png"><br>​<br>惨考链接：<a href="https://javaguide.cn/java/basis/java-basic-questions-02.html#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D">Java Guide 深拷贝和浅拷贝区别</a></p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java包装类型的缓存机制</title>
    <link href="/2020/09/21/Java%E5%9F%BA%E7%A1%80/Java%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/09/21/Java%E5%9F%BA%E7%A1%80/Java%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>Java中基本类型都有对应的包装类分别有：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code>。而它们大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值  <strong>[-128，127]</strong>  的相应类型的缓存数据，<code>Character</code> 创建了数值在  <strong>[0,127]</strong>  范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。<br>​</p><h3 id="Integer缓存源码"><a href="#Integer缓存源码" class="headerlink" title="Integer缓存源码"></a><strong>Integer缓存源码</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br>​<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">integerCacheHighPropValue</span> <span class="hljs-operator">=</span><br>            sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>        <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> parseInt(integerCacheHighPropValue);<br>                i = Math.max(i, <span class="hljs-number">127</span>);<br>                <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>            &#125;<br>        &#125;<br>        high = h;<br>​<br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>            cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br>​<br>        <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>        <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>    &#125;<br>​<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IntegerCache</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br>​<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">CharacterCache</span><span class="hljs-params">()</span>&#123;&#125;<br>​<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Character cache[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>[<span class="hljs-number">127</span> + <span class="hljs-number">1</span>];<br>​<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cache.length; i++)<br>            cache[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>((<span class="hljs-type">char</span>)i);<br>    &#125;<br>&#125;<br>​<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Character <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-keyword">if</span> (c &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// must cache</span><br>        <span class="hljs-keyword">return</span> CharacterCache.cache[(<span class="hljs-type">int</span>)c];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(c);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Boolean缓存源码"><a href="#Boolean缓存源码" class="headerlink" title="Boolean缓存源码"></a><strong>Boolean缓存源码</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">boolean</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> (b ? TRUE : FALSE);<br>&#125;<br></code></pre></td></tr></table></figure><p>由源码可见，超出范围了仍然会创建对象，缓存的范围区间的大小只是在性能和资源之间的权衡。<br><code>Float</code>、<code>Double</code>没有缓存机制</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span>;<br><span class="hljs-comment">/*直接是使用的缓存中的对象*/</span><br>System.out.println(i1 == i2);<span class="hljs-comment">// 输出 true</span><br>​<br><span class="hljs-type">Float</span> <span class="hljs-variable">i11</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br><span class="hljs-type">Float</span> <span class="hljs-variable">i22</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br><span class="hljs-comment">/*Float没有缓存机制*/</span><br>System.out.println(i11 == i22);<span class="hljs-comment">// 输出 false</span><br>​<br><span class="hljs-type">Double</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br><span class="hljs-type">Double</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br><span class="hljs-comment">/*Double没有缓存机制*/</span><br>System.out.println(i3 == i4);<span class="hljs-comment">// 输出 false</span><br>​<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i5</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i6</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">127</span>);<br><span class="hljs-comment">/*i5是用的缓存中的对象，i6是直接创建的对象*/</span><br>System.out.println(i5 == i6); <span class="hljs-comment">//输出false</span><br>​<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i7</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i8</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">128</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i9</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>System.out.println(i7 == i8); <span class="hljs-comment">//输出false</span><br><span class="hljs-comment">/*i7、i9超出 -128~127 的范围了，都是创建的对象*/</span><br>System.out.println(i7 == i9);  <span class="hljs-comment">//输出false</span><br></code></pre></td></tr></table></figure><p>谨记: <strong>所有包装类型之间的值比较，尽量都要用equals</strong><br>​<br>参考链接：<br><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88">Java Guide 包装类型的缓存机制了解么？</a></p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
